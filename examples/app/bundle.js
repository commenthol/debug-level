/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.. */ \"../../lib/browser.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(___WEBPACK_IMPORTED_MODULE_0__);\n\nwindow.localStorage.setItem('DEBUG_URL', '/debug-level');\nwindow.localStorage.setItem('DEBUG', '*');\nvar log = new (___WEBPACK_IMPORTED_MODULE_0___default())('myApp');\nvar ORD = ['th', 'st', 'nd', 'rd'];\n\nvar ordinals = function ordinals(num) {\n  return num + (num > 10 && num < 14 ? 'th' : ORD[num % 10] || ORD[0]);\n};\n\nvar LEVEL = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];\n\nvar levels = function levels() {\n  return LEVEL[Math.random() * LEVEL.length | 0];\n};\n\nvar count = 1;\nsetInterval(function () {\n  var level = levels().toLowerCase();\n  log[level]('my %s logline at %s', ordinals(count++), new Date().toString());\n}, 500);\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "../../lib/Format.js":
/*!***************************!*\
  !*** ../../lib/Format.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar stringify = __webpack_require__(/*! json-stringify-safe */ \"../../node_modules/json-stringify-safe/stringify.js\");\n\nvar replacer = function replacer(key, value) {\n  if (value instanceof Error) {\n    return value.stack || value.name + ' ' + value.message;\n  }\n\n  return value;\n};\n\nvar jFormatter = function jFormatter(obj, spaces) {\n  return stringify(obj, replacer, spaces);\n};\n\nvar formatters = {\n  s: function s(arg) {\n    return String(arg);\n  },\n  d: function d(arg) {\n    return Number(arg);\n  },\n  i: function i(arg) {\n    return parseInt(arg, 10);\n  },\n  f: function f(arg) {\n    return parseFloat(arg);\n  },\n  j: jFormatter,\n  o: jFormatter,\n  O: jFormatter\n};\nmodule.exports = Format;\n/**\n * @param {object} [opts]\n * @param {boolean} [opts.noQuotes] - remove quotes from object keys\n * @param {number} [opts.spaces] - JSON.stringify spaces\n * @param {object} [opts.formatters] - custom formatters (if needed)\n */\n\nfunction Format() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.assign(this, {\n    opts: opts,\n    formatters: Object.assign(formatters, opts.formatters)\n  });\n}\n\nFormat.prototype = {\n  get noQuotes() {\n    return this.opts.noQuotes;\n  },\n\n  set noQuotes(val) {\n    this.opts.noQuotes = !!val;\n  },\n\n  get spaces() {\n    return this.opts.spaces;\n  },\n\n  set spaces(spaces) {\n    this.opts.spaces = spaces;\n  },\n\n  /**\n   * formats arguments like `util.format`\n   * @param {...Any} arguments list - args[0] may contain \"%\" formatters\n   * @return {Array} first is formatted message, other args may follow\n   */\n  format: function format() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    switch (_typeof(args[0])) {\n      case 'string':\n        break;\n\n      case 'number':\n        args.unshift('%d');\n        break;\n\n      case 'boolean':\n        args.unshift('%s');\n        break;\n\n      default:\n        args.unshift('%O');\n    } // apply all `formatters`\n\n\n    var idx = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // don't increase the array index on escaped %\n      if (match === '%%') return match;\n      idx++;\n      var formatter = _this.formatters[format];\n\n      if (typeof formatter === 'function') {\n        var val = args[idx];\n        match = formatter(val, _this.opts.spaces);\n\n        if (_this.opts.noQuotes && typeof match === 'string') {\n          match = match.replace(/^\"/, '').replace(/\"$/m, '');\n        }\n\n        args.splice(idx, 1); // remove `args[idx]` as being inlined\n\n        idx--;\n      }\n\n      return match;\n    }); // return all remaining arguments - args[0] should be of type string, if there were formatters inside\n\n    return args;\n  }\n};\n\n//# sourceURL=webpack:///../../lib/Format.js?");

/***/ }),

/***/ "../../lib/LogBase.js":
/*!****************************!*\
  !*** ../../lib/LogBase.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar Format = __webpack_require__(/*! ./Format */ \"../../lib/Format.js\");\n\nvar _require = __webpack_require__(/*! ./utils */ \"../../lib/utils.js\"),\n    adjustLevel = _require.adjustLevel,\n    LEVELS = _require.LEVELS,\n    LOG = _require.LOG,\n    DEBUG = _require.DEBUG,\n    INFO = _require.INFO,\n    WARN = _require.WARN,\n    ERROR = _require.ERROR,\n    FATAL = _require.FATAL;\n\nvar Namespaces = __webpack_require__(/*! ./Namespaces */ \"../../lib/Namespaces.js\");\n\nfunction LogBase(name, opts) {\n  Object.assign(this, {\n    name: name,\n    opts: opts,\n    _enabled: {},\n    formatter: new Format(opts)\n  });\n  this.enable();\n}\n\nLogBase.prototype = {\n  enable: function enable(namespaces) {\n    var _this = this;\n\n    namespaces = namespaces || this.opts.namespaces;\n    var namespace = new Namespaces(namespaces);\n    this._enabled = {}; // reset\n\n    var level = namespace.isEnabled(this.name, this.opts.level);\n\n    if (level) {\n      LEVELS[adjustLevel(level, DEBUG)].forEach(function (level) {\n        _this._enabled[level] = true;\n      });\n    }\n  },\n\n  get enabled() {\n    var _this2 = this;\n\n    return this._enabled._cache || (this._enabled._cache = LEVELS[DEBUG].reduce(function (o, level) {\n      o[level] = o[level.toLowerCase()] = !!_this2._enabled[level];\n      return o;\n    }, {}));\n  },\n\n  log: function log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    } // always log\n\n\n    return this._log(LOG, args);\n  },\n  debug: function debug() {\n    if (!this._enabled.DEBUG) return;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return this._log(DEBUG, args);\n  },\n  info: function info() {\n    if (!this._enabled.INFO) return;\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return this._log(INFO, args);\n  },\n  warn: function warn() {\n    if (!this._enabled.WARN) return;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return this._log(WARN, args);\n  },\n  error: function error() {\n    if (!this._enabled.ERROR) return;\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    return this._log(ERROR, args);\n  },\n  fatal: function fatal() {\n    if (!this._enabled.FATAL) return;\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    return this._log(FATAL, args);\n  },\n  _serverinfo: function _serverinfo() {},\n\n  /**\n   * @return {object} json object\n   */\n  _formatJson: function _formatJson(level, _args) {\n    var _this$formatter;\n\n    var args = _args.slice(); // work on copy\n\n\n    var opts = this.opts;\n    var o = {\n      level: level,\n      name: this.name,\n      msg: undefined\n    };\n    var loop = true;\n\n    while (loop && args.length) {\n      // remove object only formats\n      if (/^\\s*%[oOj]\\s*$/.test(args[0])) {\n        args.shift();\n      }\n\n      switch (_typeof(args[0])) {\n        case 'string':\n          loop = false;\n          args = (_this$formatter = this.formatter).format.apply(_this$formatter, _toConsumableArray(args));\n          o.msg = args.shift();\n          break;\n\n        case 'object':\n          if (args[0] instanceof Error) {\n            (function () {\n              var err = args.shift();\n              o.err = {\n                name: err.name,\n                stack: err.stack\n              };\n              o.msg = err.message; // append other keys\n\n              Object.keys(err).forEach(function (key) {\n                o.err[key] = err[key];\n              });\n            })();\n          } else {\n            var obj = args.shift();\n\n            if (Array.isArray(obj)) {\n              o.arr = obj;\n            } else {\n              Object.assign(o, obj);\n            }\n          }\n\n          break;\n\n        default:\n          loop = false;\n          o.msg = args.shift();\n          break;\n      }\n    } // any other arguments are added to `.args`\n\n\n    if (args.length) {\n      o.args = args;\n    } // we put serverinfo and date at the end of the object\n    // for not viewing the same info e.g. if in tty\n\n\n    if (opts.serverinfo) this._serverinfo(o);\n    if (!opts.hideDate) o.time = new Date().toISOString(); // diff info is not in humanized form\n\n    o.diff = this.diff; // ensure core fields\n\n    o.level = level;\n    o.name = this.name;\n    return o;\n  },\n  _diff: function _diff() {\n    var curr = Date.now();\n    var prev = this.prev || curr;\n    this.diff = curr - prev;\n    this.prev = curr;\n  },\n  _log: function _log()\n  /* level, args */\n  {\n    /* istanbul ignore next */\n    throw new Error('needs implementation');\n  }\n};\nmodule.exports = LogBase;\n\n//# sourceURL=webpack:///../../lib/LogBase.js?");

/***/ }),

/***/ "../../lib/Namespaces.js":
/*!*******************************!*\
  !*** ../../lib/Namespaces.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n * @see https://github.com/visionmedia/debug\n */\n\n\nvar _require = __webpack_require__(/*! ./utils */ \"../../lib/utils.js\"),\n    DEBUG = _require.DEBUG,\n    INFO = _require.INFO,\n    WARN = _require.WARN,\n    ERROR = _require.ERROR,\n    FATAL = _require.FATAL,\n    OFF = _require.OFF;\n\nvar LEVELS = [DEBUG, INFO, WARN, ERROR, FATAL, OFF];\nvar LEVELS_REGEX = RegExp(\"^(\".concat(LEVELS.join('|'), \"):\"), 'i');\nmodule.exports = Namespaces;\n\nfunction Namespaces(namespaces) {\n  this.enable(namespaces);\n}\n\nNamespaces.prototype = {\n  enable: function enable(namespaces) {\n    this.skips = [];\n    this.names = [];\n    var splited = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\n    var _iterator = _createForOfIteratorHelper(splited),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _namespace = _step.value;\n        if (!_namespace) continue; // ignore empty strings\n\n        var _this$_namespaceNLeve = this._namespaceNLevel(_namespace),\n            namespace = _this$_namespaceNLeve.namespace,\n            level = _this$_namespaceNLeve.level;\n\n        if (namespace[0] === '-') {\n          this.skips.push({\n            re: new RegExp('^' + namespace.substr(1) + '$')\n          });\n        } else {\n          this.names.push({\n            re: new RegExp('^' + namespace + '$'),\n            level: level\n          });\n        }\n      } // sort names by levels\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.names = this.names.sort(function (a, b) {\n      return LEVELS.indexOf(a.level) - LEVELS.indexOf(b.level);\n    });\n  },\n  disable: function disable() {\n    /* istanbul ignore next */\n    this.enable('');\n  },\n  isEnabled: function isEnabled(name, level) {\n    if (name === '*') {\n      return level || 'DEBUG';\n    }\n\n    if (!this.names.length) {\n      return level;\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(this.skips),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _skip = _step2.value;\n\n        if (_skip.re.test(name)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(this.names),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _name = _step3.value;\n\n        if (_name.re.test(name)) {\n          return _name.level || level || 'DEBUG';\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _namespaceNLevel: function _namespaceNLevel(_namespace) {\n    var level = (LEVELS_REGEX.exec(_namespace) || [])[1];\n\n    var namespace = _namespace.replace(LEVELS_REGEX, '').replace(/\\*/g, '.*?');\n\n    return {\n      namespace: namespace,\n      level: level\n    };\n  }\n};\n\n//# sourceURL=webpack:///../../lib/Namespaces.js?");

/***/ }),

/***/ "../../lib/browser.js":
/*!****************************!*\
  !*** ../../lib/browser.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _asyncc = __webpack_require__(/*! asyncc */ \"../../node_modules/asyncc/dist/index.es.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"../../lib/utils.js\");\n\nvar _ms = _interopRequireDefault(__webpack_require__(/*! ms */ \"../../node_modules/ms/index.js\"));\n\nvar _LogBase = _interopRequireDefault(__webpack_require__(/*! ./LogBase */ \"../../lib/LogBase.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar COLOR_RESET = 'color:inherit';\n/**\n * global log options\n */\n\nvar options = {\n  level: undefined,\n  namespaces: undefined,\n  colors: true,\n  // apply coloring to browser console\n  url: undefined // [optional] url to report errors\n\n};\n/**\n * get storage\n * @private\n */\n\nvar storage = function storage() {\n  try {\n    return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined' ? chrome.storage.local : window.localStorage;\n  } catch (err) {\n    // istanbul ignore next\n    return {};\n  }\n};\n/**\n * check if console colors are supported\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n * @private\n */\n\n\nvar supportsColors = function supportsColors() {\n  var tmp;\n  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent; // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n\n  var isElectron = typeof window !== 'undefined' && (tmp = window.process) && tmp.type === 'renderer'; // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n  var isReactNative = typeof document !== 'undefined' && (tmp = document.documentElement) && (tmp = tmp.style) && tmp.WebkitAppearance; // is firebug? http://stackoverflow.com/a/398120/376773\n\n  var isFireBug = typeof window !== 'undefined' && (tmp = window.console) && (tmp.firebug || tmp.exception && tmp.table);\n\n  if (isElectron) {\n    // istanbul ignore next\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (/(edge|trident)\\/(\\d+)/i.exec(userAgent)) {\n    // istanbul ignore next\n    return false;\n  }\n\n  return !!(isReactNative || isFireBug || // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  /firefox\\/(\\d+)/i.exec(userAgent) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n  /applewebkit\\/(\\d+)/i.exec(userAgent));\n};\n/**\n * creates a new logger for the browser\n * @constructor\n * @param {String} name - namespace of Logger\n */\n\n\nfunction Log(name, opts) {\n  if (!(this instanceof Log)) return new Log(name, opts);\n\n  var _storage = storage();\n\n  Object.assign(options, (0, _utils.inspectOpts)(_storage), (0, _utils.inspectNamespaces)(_storage));\n  options.colors = options.colors === false ? false : supportsColors();\n\n  _LogBase[\"default\"].call(this, name, Object.assign({}, options, opts));\n\n  var colorFn = function colorFn(c) {\n    return \"color:\".concat(c);\n  };\n\n  this.color = (0, _utils.selectColor)(name, colorFn);\n  this.levColors = (0, _utils.levelColors)(colorFn);\n  this.queue = new _asyncc.Queue(this._sendLog.bind(this), 3);\n}\n\nObject.setPrototypeOf(Log.prototype, _LogBase[\"default\"].prototype);\nObject.assign(Log.prototype, {\n  /**\n   * render arguments to console.log\n   * @public\n   * @param {Array} args - console.log arguments\n   * @param {String} level - level of log line (might be used for custom Logger which uses different streams per level)\n   * @return {String}\n   */\n  render: function render(args) {\n    var _console;\n\n    (_console = console).log.apply(_console, _toConsumableArray(args)); // eslint-disable-line no-console\n\n\n    return args;\n  },\n\n  /**\n   * send log to server\n   * @param {Array} args - log arguments\n   * @param {String} level - log level\n   */\n  send: function send(args, level) {\n    var o = this._formatJson(level, args);\n\n    o.userAgent = navigator.userAgent;\n    var str = this.formatter.format(o)[0];\n    this.queue.push(str);\n  },\n\n  /**\n   * format log arguments\n   * @private\n   */\n  _log: function _log(level, args) {\n    this._diff();\n\n    var _args = this._formatArgs(level, args);\n\n    var res = this.render(_args, level);\n\n    if (this.opts.url) {\n      this.send(args, level);\n    }\n\n    return res;\n  },\n\n  /**\n   * format arguments for console.log\n   * @private\n   * @return {Array} args for console.log\n   */\n  _formatArgs: function _formatArgs(level, _args) {\n    var _this = this;\n\n    var args = _args.slice(); // work on copy\n\n\n    var color = this.color;\n\n    if (typeof args[0] !== 'string') {\n      args.unshift('%O');\n    }\n\n    args[0] = [this._color(level), this._color(this.name), args[0], this._color('+' + (0, _ms[\"default\"])(this.diff))].join(' ');\n\n    if (this.opts.colors) {\n      args.splice(1, 0, color + ';font-weight:bold', COLOR_RESET);\n      args.splice(1, 0, this.levColors[level], COLOR_RESET);\n    }\n\n    var idx = 0;\n    var lastC; // apply custom formatters\n\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      if (match === '%%') return match;\n      idx++;\n\n      switch (format) {\n        case 's':\n        case 'd':\n        case 'i':\n        case 'f':\n        case 'o':\n        case 'O':\n          break;\n\n        case 'c':\n          lastC = idx;\n          break;\n\n        default:\n          {\n            var formatter = _this.formatter.formatters[format];\n\n            if (typeof formatter === 'function') {\n              var val = args[idx];\n              match = formatter(val);\n              args.splice(idx, 1); // remove `args[idx]` as being inlined\n\n              idx--;\n            }\n          }\n      }\n\n      return match;\n    });\n\n    if (this.opts.colors) {\n      args.splice(lastC - 1, 0, color, COLOR_RESET);\n    }\n\n    return args;\n  },\n\n  /**\n   * transfer log to server via zero pixel image request\n   */\n  _sendLog: function _sendLog(str, cb) {\n    var img = new Image();\n\n    var done = function done() {\n      return cb();\n    };\n\n    img.onload = done;\n    img.onerror = done;\n    img.onabort = done;\n    img.src = this.opts.url + '/0.gif?id=' + (0, _utils.random)(6) + '&log=' + encodeURIComponent(str);\n  },\n\n  /**\n   * Add colors, style to string\n   * @private\n   */\n  _color: function _color(str) {\n    return this.opts.colors ? \"%c\".concat(str, \"%c\") : str;\n  }\n});\n/**\n * Apply (and get) global options\n * @param {object} [opts] - changed options\n * @return {object} global options\n */\n\nLog.options = function (opts) {\n  if (!opts) return Object.assign({}, options);\n  Object.assign(options, opts, {\n    colors: opts.colors === false ? false : supportsColors()\n  });\n  return options;\n};\n/**\n * save options in `localStorage`\n */\n\n\nLog.save = function () {\n  var _storage = storage();\n\n  Log.reset();\n  (0, _utils.saveOpts)(_storage, options);\n};\n/**\n * reset saved options\n */\n\n\nLog.reset = function () {\n  var _storage = storage();\n\n  Object.keys(_storage).forEach(function (key) {\n    if (/^(DEBUG|DEBUG_.*)$/.test(key)) {\n      _storage.removeItem(key);\n    }\n  });\n};\n\nmodule.exports = Log;\n\n//# sourceURL=webpack:///../../lib/browser.js?");

/***/ }),

/***/ "../../lib/utils.js":
/*!**************************!*\
  !*** ../../lib/utils.js ***!
  \**************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n */\n\nvar LOG = 'LOG',\n    DEBUG = 'DEBUG',\n    INFO = 'INFO',\n    WARN = 'WARN',\n    ERROR = 'ERROR',\n    FATAL = 'FATAL',\n    OFF = 'OFF';\nvar LEVELS = {\n  DEBUG: [FATAL, ERROR, WARN, INFO, DEBUG],\n  INFO: [FATAL, ERROR, WARN, INFO],\n  WARN: [FATAL, ERROR, WARN],\n  ERROR: [FATAL, ERROR],\n  FATAL: [FATAL],\n  OFF: [OFF]\n};\nvar COLORS = ['#6600FF', '#3333FF', '#3333CC', '#0066FF', '#0066CC', '#0066FF', '#006633', '#006666', '#006600', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#009900', '#009933', '#009966', '#009999', '#00CCFF', '#00CCCC', '#FF9900', '#FF9933', '#FF6600', '#FF6633', '#FF0000', '#FF0033', '#FF3300', '#FF3300', '#FF3333', '#CC0000', '#CC0033', '#CC0066', '#FF0066', '#FF3366', '#FF00FF', '#FF33FF', '#CC00CC', '#990099']; // // dark colors for bright background\n// const COLORS_DARK = [\n//   '#0000FF', '#0000CC', '#3300CC', '#000099',\n//   '#003399', '#333399', '#330099', '#3300CC',\n//   '#000066', '#000099', '#660066'\n// ]\n//\n// // bright colors for dark background\n// const COLORS_BRIGHT = [\n//   '#00FF00', '#00FF33', '#00FF66', '#00FF99',\n//   '#00FFFF', '#00FFCC',\n//   '#FFFF00', '#FFFF33', '#FFCC33', '#FFCC66'\n// ]\n\nvar LEVEL_COLORS = {\n  LOG: '#999999',\n  DEBUG: '#0066CC',\n  INFO: '#009900',\n  WARN: '#FF9900',\n  ERROR: '#CC0000',\n  FATAL: '#CC00CC'\n};\n\nvar adjustLevel = function adjustLevel(level, _default) {\n  level = (level || '').toUpperCase();\n  return LEVELS[level] ? level : _default;\n};\n/**\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n */\n\n\nvar inspectOpts = function inspectOpts(obj) {\n  return Object.keys(obj).filter(function (key) {\n    return /^debug_/i.test(key);\n  }).reduce(function (opts, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n      return k.toUpperCase();\n    }); // coerce string value into JS value\n\n    var val = obj[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n\n    if (prop === 'stream' || prop === 'formatters') {// do nothing\n    } else if (prop === 'level') {\n      val = adjustLevel(obj[key]);\n      if (val) opts[prop] = val;\n    } else if (prop === 'url') {\n      opts[prop] = obj[key];\n    } else {\n      opts[prop] = val;\n    }\n\n    return opts;\n  }, {});\n};\n\nvar saveOpts = function saveOpts(obj, options) {\n  Object.keys(options).forEach(function (prop) {\n    if (prop === 'stream' || prop === 'formatters') return; // do not safe stream option\n\n    var key = 'DEBUG_' + prop.replace(/([A-Z])/g, function (_, prop) {\n      return '_' + prop.toLowerCase();\n    });\n    if (prop === 'namespaces') key = 'DEBUG';\n    key = key.toUpperCase();\n    obj[key] = options[prop];\n  });\n};\n\nvar selectColor = function selectColor(namespace, fn) {\n  var hash = 0;\n\n  for (var i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  var pos = Math.abs(hash) % COLORS.length;\n  var color = fn(COLORS[pos]);\n  return color;\n};\n\nvar levelColors = function levelColors(fn) {\n  var colors = Object.keys(LEVEL_COLORS).reduce(function (colors, level) {\n    colors[level] = fn(LEVEL_COLORS[level]);\n    return colors;\n  }, {});\n  return colors;\n};\n\nvar inspectNamespaces = function inspectNamespaces(obj) {\n  var namespaces = obj.DEBUG || obj.debug;\n  if (namespaces) return {\n    namespaces: namespaces\n  };\n};\n\nvar random = function random(len) {\n  return Math.random().toString(16).toLowerCase().substr(2, len);\n};\n\nmodule.exports = {\n  LOG: LOG,\n  DEBUG: DEBUG,\n  INFO: INFO,\n  WARN: WARN,\n  ERROR: ERROR,\n  FATAL: FATAL,\n  OFF: OFF,\n  LEVELS: LEVELS,\n  COLORS: COLORS,\n  LEVEL_COLORS: LEVEL_COLORS,\n  adjustLevel: adjustLevel,\n  inspectOpts: inspectOpts,\n  saveOpts: saveOpts,\n  inspectNamespaces: inspectNamespaces,\n  selectColor: selectColor,\n  levelColors: levelColors,\n  random: random\n};\n\n//# sourceURL=webpack:///../../lib/utils.js?");

/***/ }),

/***/ "../../node_modules/asyncc/dist/index.es.js":
/*!**************************************************!*\
  !*** ../../node_modules/asyncc/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"AsynccError\": () => (/* binding */ AsynccError),\n/* harmony export */   \"NoPromise\": () => (/* binding */ NoPromise),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"_setImmediate\": () => (/* binding */ _setImmediate),\n/* harmony export */   \"compose\": () => (/* binding */ compose),\n/* harmony export */   \"connect\": () => (/* binding */ connect),\n/* harmony export */   \"doUntil\": () => (/* binding */ doUntil),\n/* harmony export */   \"doWhilst\": () => (/* binding */ doWhilst),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"eachLimit\": () => (/* binding */ eachLimit),\n/* harmony export */   \"eachSeries\": () => (/* binding */ eachSeries),\n/* harmony export */   \"noPromise\": () => (/* binding */ noPromise),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel$1),\n/* harmony export */   \"parallelLimit\": () => (/* binding */ parallelLimit),\n/* harmony export */   \"queue\": () => (/* binding */ queue),\n/* harmony export */   \"retry\": () => (/* binding */ retry),\n/* harmony export */   \"series\": () => (/* binding */ series),\n/* harmony export */   \"times\": () => (/* binding */ times),\n/* harmony export */   \"until\": () => (/* binding */ until),\n/* harmony export */   \"whilst\": () => (/* binding */ whilst)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n* setImmediate wrapper for different environments\n* @method _setImmediate\n* @static\n*/\nvar _setImmediate = function () {\n  /* istanbul ignore next */\n  if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && typeof process.nextTick === 'function') {\n    // nodejs\n    return process.nextTick;\n  } else if (typeof setImmediate === 'function') {\n    // supporting browsers\n    return setImmediate;\n  } else {\n    // fallback\n    return function (fn) {\n      setTimeout(fn, 0);\n    };\n  }\n}();\n\nvar AsynccError = /*@__PURE__*/function (Error) {\n  function AsynccError(message, errors, errpos) {\n    Error.call(this, message);\n    Object.assign(this, {\n      name: 'AsynccError',\n      message: message,\n      errors: errors,\n      errpos: errpos,\n      stack: this.stack ||\n      /* istanbul ignore next */\n      new Error().stack\n    });\n  }\n\n  if (Error) AsynccError.__proto__ = Error;\n  AsynccError.prototype = Object.create(Error && Error.prototype);\n  AsynccError.prototype.constructor = AsynccError;\n  return AsynccError;\n}(Error);\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a task are passed no the next task.\n * Stops on errors and immediatelly calls optional `callback` in this case.\n *\n * @name compose\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type\n * `function (arg: any, cb: function)`\n * `arg` - an argument which is passed from one task to the other\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg: any, cb: function)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback `function(err: <Error>, res: any)`\n * @example\n * var c = compose(\n *   (res, cb) => { cb(null, res + 1) },\n *   (res, cb) => { cb('error', res * 2) }, // breaks here on first error\n *   (res, cb) => { cb(null, res + 3) },\n * )\n * c(2, function (err, res) {\n *   //> err = 'error'\n *   //> res = 6\n * })\n */\n\n\nfunction compose() {\n  var tasks = [],\n      len = arguments.length;\n\n  while (len--) {\n    tasks[len] = arguments[len];\n  }\n\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n\n  return function (arg, callback) {\n    var i = 0;\n\n    function run(err, res) {\n      var fn = tasks[i++];\n\n      if (err || !fn) {\n        callback && callback(err, res);\n      } else {\n        fn(res, run);\n      }\n    }\n\n    run(null, arg);\n  };\n}\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a **task** are passed to the next task.\n * Passed or thrown errors in tasks get trapped with\n * functions of arity 3 `function (err, res, cb)` called here **trap**.\n * In case that there is no previous error, a **trap** acts as \"no-op\".\n * In case that no **trap** is defined then the chain exits to an optional `callback`.\n *\n * @name connect\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type **task**\n * `function (arg: any, cb: function)` or **trap** `function (err: <Error>, arg: any, cb: function)` where\n * `arg` - an argument which is passed from one task to the other\n * `err` - a trapped error from previous tasks\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg, cb)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback function `function(err: <Error>, res: any)`\n * @example\n * var c = connect(\n *   (res, cb) => { cb(null, res + 1) },      // task\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - \"no-op\" here as there is no previous error\n *   (res, cb) => { cb(null, res * 2) }       // task\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 6\n * })\n *\n * @example <caption>With error traps</caption>\n * var c = connect(\n *   (res, cb) => { cb('error', res + 1) },   // task - error is passed to next task\n *   (res, cb) => { cb(null, res * 2) },      // task - \"no-op\", jumps over this task due to previous error\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - error gets trapped here (arity === 3)\n *   (res, cb) => { cb(null, res * 2) }       // task - continues\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 12\n * })\n *\n */\n\n\nfunction connect() {\n  var tasks = [],\n      len = arguments.length;\n\n  while (len--) {\n    tasks[len] = arguments[len];\n  }\n\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n\n  return function (arg, callback) {\n    var i = 0;\n    run(null, arg);\n\n    function run(err, res) {\n      var fn = tasks[i++];\n\n      try {\n        if (err) {\n          // search for next function of arity 3\n          while (fn && fn.length !== 3) {\n            fn = tasks[i++];\n          }\n\n          fn && fn(err, res, run);\n        } else {\n          // jump over all error traps\n          while (fn && fn.length > 2) {\n            fn = tasks[i++];\n          }\n\n          fn && fn(res, run); // step\n        }\n      } catch (e) {\n        run(e, res);\n      }\n\n      if (!fn) {\n        callback && callback(err, res);\n      }\n    }\n  };\n}\n/**\n* Run `task` one or more times until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name doUntil\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doUntil(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index >= 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction doUntil(task, test, callback) {\n  var i = 0;\n\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n\n  run();\n}\n/**\n* Run `task` one or more times until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name doWhilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doWhilst(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index < 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction doWhilst(task, test, callback) {\n  doUntil(task, function (n) {\n    return !test(n);\n  }, callback);\n}\n\nfunction parallel(limit, length, run, opts, callback) {\n  if (opts === void 0) opts = {};\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  limit = Math.abs(limit || length);\n  var errpos = [];\n  var errors = new Array(length).fill();\n  var results = new Array(length).fill();\n  var i = 0;\n  var l = length;\n  var done = 0;\n\n  if (l === 0) {\n    _final();\n\n    return;\n  }\n\n  if (opts.timeout) {\n    setTimeout(function () {\n      /* istanbul ignore else */\n      if (l) {\n        _final('err_timeout');\n      }\n    }, opts.timeout);\n  }\n\n  limit = limit < length ? limit : length;\n\n  while (i < limit) {\n    run(i++, cb);\n  }\n\n  function _final(errMsg) {\n    if (done++) {\n      return;\n    }\n\n    var err = null;\n\n    if (errpos.length || errMsg) {\n      err = new AsynccError(errMsg || 'err', errors, errpos);\n    }\n\n    callback && callback(err, results);\n  }\n\n  function cb(j, err, res) {\n    results[j] = res;\n    errors[j] = err;\n\n    if (err) {\n      errpos.push(j);\n\n      if (opts.bail) {\n        _final('err_bail');\n\n        return;\n      }\n    }\n\n    l--;\n\n    if (i < length) {\n      run(i++, cb);\n    } else if (!l) {\n      _final();\n    }\n  }\n}\n/**\n* Run `items` on async `task` function in parallel limited to `limit` parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name eachLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* eachLimit(2, [1, 2, 3, 4],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null, 'error']\n*     //> err.errpos = [1, 3]\n*     //> res = [1, 4, 5, 7]\n*   }\n* )\n*/\n\n\nfunction eachLimit(limit, items, task, opts, callback) {\n  function run(j, cb) {\n    task(items[j], function (err, res) {\n      cb(j, err, res);\n    }, j);\n  }\n\n  parallel(limit, items.length, run, opts, callback);\n}\n/**\n* Run `items` on async `task` function in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name each\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* each([1, 2, 3],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null]\n*     //> err.errpos = [1]\n*     //> res = [1, 4, 5]\n*   }\n* )\n*/\n\n\nfunction each(items, task, opts, callback) {\n  eachLimit(0, items, task, opts, callback);\n}\n/**\n * Run `items` on async `task` function in series. Stops at the first error encountered.\n *\n * @name eachSeries\n * @memberOf module:serial\n * @static\n * @method\n * @param {Array<any>} items - Array of items\n * @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n * @param {Function} [callback] - optional callback `function (errors: <Error>, result: Array<any>)`\n * @example\n * eachSeries([1, 2, 3],\n *   (item, cb, index) => {\n *     setImmediate(() => {\n *       cb(index % 2 ? null : 'error', item + index)\n *     })\n *   }, (err, res) => {\n *     //> err = 'error'\n *     //> res = [1, 4]\n *   }\n * )\n */\n\n\nfunction eachSeries(items, task, callback) {\n  var length = items.length;\n  var results = [];\n  var i = 0;\n\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n\n  run();\n\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else  */\n\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(items[i], cb, i++);\n  }\n}\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* This method is similar to {@link module:serial.connect|connect} but allows adding `tasks` on the go through chaining.\n*\n* @name NoPromise\n* @class\n* @param {Any} arg - initial argument which is passed to first chain\n* @example <caption>Normal usage</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb(null, res)\n* }).end((err, res) => {\n*   //> err = null\n*   //> res = [1, 2]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Catch errors</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb('err1', res)             // <-- cause an error\n* }).catch((err, res, cb) => {  // catches err1\n*   res.push(err)\n*   cb(null, res)               // <-- continue normally\n* }).then((res, cb) => {\n*   res.push(3)\n*   cb(null, res)\n* }).catch((err, res, cb) => {  // jumps over, as there is no error in the chain\n*   res.push(4)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(5)\n*   cb('err2', res)             // <-- next error\n* }).end((err, res) => {\n*   //> err = 'err2'\n*   //> res = [1, 2, 'err1', 3, 5]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Deferred usage</caption>\n* var arr = []\n* // creates a new instance passing `arr`\n* var n = new NoPromise(arr)\n* // execute the first async method\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* })\n* // take a time off\n* setTimeout(() => {\n*   // continue processing\n*   n.then((res, cb) => {\n*     res.push(2)\n*     cb(null, res)\n*   }).end((err, res) => {\n*     //> err = null\n*     //> res = [1, 2]\n*     //> (arr ==== res) = true\n*   })\n* }, 10)\n*/\n\n\nfunction NoPromise(arg) {\n  this._tasks = [];\n  this.result = arg;\n  this.error = undefined;\n  this._lock = false;\n}\n\nNoPromise.prototype = {\n  /**\n   * runs the next function\n   * @private\n   */\n  _run: function _run() {\n    var this$1 = this;\n\n    if (this._lock) {\n      return;\n    }\n\n    this._lock = true;\n\n    var task = this._tasks.shift();\n\n    var tstType = this.error ? ['catch', 'end'] : ['then', 'end'];\n\n    while (task && !~tstType.indexOf(task.type)) {\n      task = this._tasks.shift();\n    }\n\n    if (task) {\n      var cb = function cb(err, res) {\n        this$1.error = err;\n        this$1.result = res || this$1.result;\n        this$1._lock = false;\n\n        this$1._run();\n      };\n\n      var fn = task.fn;\n\n      if (task.type === 'end') {\n        // .end\n        fn(this.error, this.result);\n      } else {\n        try {\n          if (task.type === 'catch') {\n            // .catch\n            fn(this.error, this.result, cb);\n          } else {\n            // .then\n            fn(this.result, cb);\n          }\n        } catch (e) {\n          cb(e);\n        }\n      }\n    } else {\n      this._lock = false;\n    }\n  },\n\n  /**\n   * Chain the next async function\n   * @param {Function} task - async function `function (res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  then: function then(task) {\n    this._tasks.push({\n      type: 'then',\n      fn: task\n    });\n\n    this._run();\n\n    return this;\n  },\n\n  /**\n   * Catch any previous errors from the chain\n   * @param {Function} trap - async function `function (err: <Error>, res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  \"catch\": function _catch(trap) {\n    this._tasks.push({\n      type: 'catch',\n      fn: trap\n    });\n\n    this._run();\n\n    return this;\n  },\n\n  /**\n   * End the chain\n   * @param {Function} callback - `function (err: <Error>, res: any)`\n   */\n  end: function end(callback) {\n    this._tasks.push({\n      type: 'end',\n      fn: callback\n    });\n\n    this._run();\n  }\n};\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* See full API here {@link NoPromise}.\n*\n* @name noPromise\n* @memberOf module:serial\n* @static\n* @method\n* @param {Any} arg - initial argument which is passed to first chain\n* @return {NoPromise}\n*/\n\nfunction noPromise(arg) {\n  return new NoPromise(arg);\n}\n/**\n* Run `tasks` callback functions in parallel limited to `limit` parallel\n* running tasks.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallelLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n*\n* @example\n* // runs 2 tasks in parallel\n* parallelLimit(2, [\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errorpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\n\n\nfunction parallelLimit(limit, tasks, opts, callback) {\n  function run(j, cb) {\n    tasks[j](function (err, res) {\n      cb(j, err, res);\n    });\n  }\n\n  parallel(limit, tasks.length, run, opts, callback);\n}\n/**\n* Run `tasks` callback functions in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallel\n* @memberOf module:parallel\n* @static\n* @method\n\n* @param {Array<Function>} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* parallel([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\n\n\nfunction parallel$1(tasks, opts, callback) {\n  parallelLimit(0, tasks, opts, callback);\n}\n/**\n* Creates an Array which adds items by priority\n*/\n\n\nfunction PrioArray() {\n  this.reset();\n}\n\nPrioArray.prototype = {\n  /**\n  * length of Array\n  */\n  get length() {\n    return this.items.length;\n  },\n\n  /**\n  * shift item from array\n  * @return {Any} item\n  */\n  shift: function shift() {\n    return (this.items.shift() ||\n    /* istanbul ignore next */\n    {}).item;\n  },\n\n  /**\n  * push `item` to Array using priority\n  * @param {Any} item\n  * @param {Number} [prio=Infinity] - priority `0 ... Infinity` - lower values have higher priority\n  */\n  push: function push(item, prio) {\n    var items = this.items;\n\n    if (typeof prio !== 'number') {\n      prio = Infinity;\n      items.push({\n        prio: prio,\n        item: item\n      });\n    } else {\n      var found;\n      prio = Math.abs(prio);\n\n      for (var i = 0; i < items.length; i++) {\n        if (prio < items[i].prio) {\n          items.splice(i, 0, {\n            prio: prio,\n            item: item\n          });\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        items.push({\n          prio: prio,\n          item: item\n        });\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * unshift `item` to Array using priority\n  * @param {Any} item\n  */\n  unshift: function unshift(item) {\n    this.items.unshift({\n      prio: 0,\n      item: item\n    });\n    return this;\n  },\n\n  /**\n  * removes all items in the Array\n  */\n  reset: function reset() {\n    this.items = [];\n  }\n};\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* @name Queue\n* @methodOf: module:parallel\n* @class\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @example <caption>Default usage</caption>\n* var arr = []\n* var q = new Queue((item, cb) => {\n*   arr.push(item)\n*   cb(null, item)\n* })\n* // push item \"one\" at end of queue\n* q.push('one', (err, res) => {\n*   console.log(res + ' finished')\n* })\n* // add item \"two\" at start of queue\n* q.unshift('two', () => {\n*   console.log('two finished')\n* })\n* // called when all items in queue where processed\n* q.drain(() => {\n*   console.log(arr)\n*   //> arr = ['one', 'two']\n* })\n* @example <caption>Using priorities</caption>\n* let arr = []\n*\n* let q = new Queue(function (item, cb) {\n*   arr.push(item)\n*   cb()\n* }, 2)\n*\n* q.concat([100, 101, 102], 3) // priority = 3 - last (but 2 items already processed)\n* q.concat([0, 1, 2], 1)       // priority = 1 - first\n* q.concat([10, 11, 12], 2)    // priority = 2 - second\n*\n* q.drain(() => {\n*   //> arr = [ 100, 101, 0, 1, 2, 10, 11, 12, 102 ])\n* })\n*/\n\nfunction Queue(task, concurrency) {\n  this._task = task;\n  this._concurrency = Math.abs(concurrency || 1);\n  this._worker = 0;\n  this._paused = false;\n  this._items = new PrioArray();\n}\n\nQueue.prototype = {\n  /**\n  * process items in queue\n  * @private\n  */\n  _run: function _run() {\n    var this$1 = this;\n    var ref = this;\n    var _items = ref._items;\n    var _drain = ref._drain;\n    this._worker -= 1;\n\n    if (_items.length === 0) {\n      if (this._worker <= 0) {\n        this._worker = 0;\n        _drain && _drain();\n      }\n    } else {\n      this._worker += 1;\n\n      var ref$1 = _items.shift();\n\n      var item = ref$1[0];\n      var cb = ref$1[1];\n\n      this._task(item, function (err, res) {\n        cb && cb(err, res);\n\n        _setImmediate(function () {\n          // prevent RangeError: Maximum call stack size exceeded for sync tasks\n          this$1._run();\n        });\n      });\n    }\n  },\n\n  /**\n  * start processing queue or add workers up to concurrency\n  * @private\n  */\n  _start: function _start() {\n    while (!this._paused && this._worker < Math.min(this._concurrency, this._items.length)) {\n      this._worker += 1;\n\n      this._run();\n    }\n\n    return this;\n  },\n\n  /**\n  * Check if queue is paused\n  * @return {Boolean} `true` if paused\n  */\n  get paused() {\n    return this._paused;\n  },\n\n  /**\n  * Check if queue is idle - means no items in queue and no workers running\n  * @return {Boolean} `true` if idle\n  */\n  get idle() {\n    return !this.length && this._worker === 0;\n  },\n\n  /**\n  * Number of items waiting in the queue to get processed\n  * @return {Number} number of items in queue\n  */\n  get length() {\n    return this._items.length;\n  },\n\n  /**\n  * Pause processing\n  * @return {this} for chaining\n  */\n  pause: function pause() {\n    this._paused = true;\n    return this;\n  },\n\n  /**\n  * Resume processing\n  * @return {this} for chaining\n  */\n  resume: function resume() {\n    this._paused = false;\n    return this._start();\n  },\n\n  /**\n  * Reset the queue by removing all pending items from the queue\n  * @return {this} for chaining\n  */\n  reset: function reset() {\n    this._items.reset();\n\n    return this;\n  },\n\n  /**\n  * Number of items being processed\n  * @return {Number} number of items processed\n  */\n  running: function running() {\n    return this._worker;\n  },\n\n  /**\n  * push `item` onto queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  push: function push(item, callback, priority) {\n    return this.concat([item], callback, priority);\n  },\n\n  /**\n  * concat `items` onto queue - fills the queue first with `items` before starting processing\n  * @param {Any[]} items\n  * @param {Function} [callback] - optional callback if single item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  concat: function concat(items, callback, priority) {\n    var this$1 = this;\n\n    if (typeof callback === 'number') {\n      priority = callback;\n      callback = undefined;\n    }\n\n    items.forEach(function (item) {\n      this$1._items.push([item, callback], priority);\n    });\n    return this._start();\n  },\n\n  /**\n  * put `item` at the very beginnning of the queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @return {this} for chaining\n  */\n  unshift: function unshift(item, callback) {\n    this._items.unshift([item, callback]);\n\n    return this._start();\n  },\n\n  /**\n  * @param {Function} [callback] - optional callback called if all queue items got processed\n  * @return {this} for chaining\n  */\n  drain: function drain(callback) {\n    this._drain = callback;\n    return this;\n  }\n};\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* See full API here {@link Queue}.\n*\n* @name queue\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @return {Queue}\n*/\n\nfunction queue(task, concurrency) {\n  return new Queue(task, concurrency);\n}\n/**\n* @private\n*/\n\n\nfunction _times(num, opts) {\n  opts = opts || {};\n  var fn = _setImmediate;\n  var lag = 0;\n  var times = num;\n\n  if (typeof num !== 'number') {\n    times = num.times;\n    lag = num.lag || 0;\n  }\n\n  times = times || opts.times || 0;\n\n  if (lag) {\n    fn = setTimeout;\n  }\n\n  return {\n    times: times,\n    lag: lag,\n    fn: fn\n  };\n}\n/**\n* Run `task` max. `times` times. Stops at first iteration where no error is returned.\n*\n* Calls `callback` if `times` is reached or `task` returned no error.\n*\n* @name retry\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - retry max. `times` times - default=2\n* @param {Number} [times.times=2] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n* @example\n* let arr = []\n* retry({times: 3, lag: 100}, // max. 3 retries with 100ms time-lag between retries\n*   (cb, index) => { // task\n*     let err = index < 2 ? new Error() : null\n*     arr.push(index)\n*     cb(err, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 2\n*     //> arr = [0, 1, 2]\n*   }\n* )\n*/\n\n\nfunction retry(num, task, callback) {\n  var i = 0;\n\n  var ref = _times(num, {\n    times: 2\n  });\n\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n  run();\n\n  function cb(err, res) {\n    if (!err || i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n}\n/**\n* Run `tasks` callback functions in series\n* The function breaks after the first error encountered and calls optional\n* `callback` function\n*\n* @name series\n* @memberOf module:serial\n* @static\n* @method\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: Error, res: Array<any>)`\n*\n* @example\n* series([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) }, // breaks on first error\n*   (cb) => { cb(null, 3) },\n* ], (err, res) => {\n*   //> err = 'error'\n*   //> res = [1, 2]\n* })\n*/\n\n\nfunction series(tasks, callback) {\n  var length = tasks.length;\n  var results = [];\n  var i = 0;\n\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n\n  run();\n\n  function run() {\n    tasks[i++](cb);\n  }\n\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else */\n\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n}\n/**\n* Run `task` repeatedly until number `times` is reached.\n*\n* Stops at the first error encountered.\n* An optional `lag` between retries may be used.\n*\n* @name times\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - runs `times` times. If `times < 0` then \"times\" cycles endlessly until an error occurs.\n* @param {Number} [times.times=0] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: Array<any>)`\n*\n* @example\n* let arr = []\n* times({times: 4, lag: 100}, // 4 times with 100ms time-lag between retries\n*   (cb, index) => {\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction times(num, task, callback) {\n  var i = 0;\n\n  var ref = _times(num);\n\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n\n  if (times) {\n    run();\n  } else {\n    callback && callback();\n  }\n\n  function cb(err, res) {\n    if (err || times > 0 && i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n}\n/**\n* Run `task` repeatedly until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name until\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* until(\n*   (index) => {        // test\n*     return index >= 4\n*   }, (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction until(test, task, callback) {\n  var i = 0;\n\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n\n  if (!test(i)) {\n    run();\n  } else {\n    callback && callback();\n  }\n}\n/**\n* Run `task` repeatedly until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name whilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* whilst(\n*   (index) => (index < 4), // test\n*   (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction whilst(test, task, callback) {\n  until(function (n) {\n    return !test(n);\n  }, task, callback);\n}\n/**\n* Serial execution patterns\n* @module serial\n*/\n\n\nvar index = {\n  _setImmediate: _setImmediate,\n  AsynccError: AsynccError,\n  compose: compose,\n  connect: connect,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  each: each,\n  eachLimit: eachLimit,\n  eachSeries: eachSeries,\n  noPromise: noPromise,\n  NoPromise: NoPromise,\n  parallel: parallel$1,\n  parallelLimit: parallelLimit,\n  queue: queue,\n  Queue: Queue,\n  retry: retry,\n  series: series,\n  times: times,\n  until: until,\n  whilst: whilst\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n\n\n//# sourceURL=webpack:///../../node_modules/asyncc/dist/index.es.js?");

/***/ }),

/***/ "../../node_modules/json-stringify-safe/stringify.js":
/*!***********************************************************!*\
  !*** ../../node_modules/json-stringify-safe/stringify.js ***!
  \***********************************************************/
/***/ ((module, exports) => {

eval("exports = module.exports = stringify;\nexports.getSerialize = serializer;\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [],\n      keys = [];\n  if (cycleReplacer == null) cycleReplacer = function cycleReplacer(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\";\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n  };\n  return function (key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);\n    } else stack.push(value);\n\n    return replacer == null ? value : replacer.call(this, key, value);\n  };\n}\n\n//# sourceURL=webpack:///../../node_modules/json-stringify-safe/stringify.js?");

/***/ }),

/***/ "../../node_modules/ms/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ms/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///../../node_modules/ms/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;