/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.. */ \"../../src/browser.js\");\n\nwindow.localStorage.setItem('DEBUG_URL', '/debug-level');\nwindow.localStorage.setItem('DEBUG', '*');\nvar log = new ___WEBPACK_IMPORTED_MODULE_0__[\"default\"]('myApp');\nvar ORD = ['th', 'st', 'nd', 'rd'];\n\nvar ordinals = function ordinals(num) {\n  return num + (num > 10 && num < 14 ? 'th' : ORD[num % 10] || ORD[0]);\n};\n\nvar LEVEL = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];\n\nvar levels = function levels() {\n  return LEVEL[Math.random() * LEVEL.length | 0];\n};\n\nvar count = 1;\nsetInterval(function () {\n  var level = levels().toLowerCase();\n  log[level]('my %s logline at %s', ordinals(count++), new Date().toString());\n}, 500);\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "../../node_modules/asyncc/dist/index.es.js":
/*!**************************************************!*\
  !*** ../../node_modules/asyncc/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsynccError\": () => (/* binding */ AsynccError),\n/* harmony export */   \"NoPromise\": () => (/* binding */ NoPromise),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"_setImmediate\": () => (/* binding */ _setImmediate),\n/* harmony export */   \"compose\": () => (/* binding */ compose),\n/* harmony export */   \"connect\": () => (/* binding */ connect),\n/* harmony export */   \"default\": () => (/* binding */ index),\n/* harmony export */   \"doUntil\": () => (/* binding */ doUntil),\n/* harmony export */   \"doWhilst\": () => (/* binding */ doWhilst),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"eachLimit\": () => (/* binding */ eachLimit),\n/* harmony export */   \"eachSeries\": () => (/* binding */ eachSeries),\n/* harmony export */   \"noPromise\": () => (/* binding */ noPromise),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"parallelLimit\": () => (/* binding */ parallelLimit),\n/* harmony export */   \"queue\": () => (/* binding */ queue),\n/* harmony export */   \"retry\": () => (/* binding */ retry),\n/* harmony export */   \"series\": () => (/* binding */ series),\n/* harmony export */   \"times\": () => (/* binding */ times),\n/* harmony export */   \"until\": () => (/* binding */ until),\n/* harmony export */   \"whilst\": () => (/* binding */ whilst)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n* setImmediate wrapper for different environments\n* @method _setImmediate\n* @static\n*/\nvar _setImmediate = function () {\n  /* istanbul ignore next */\n  if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && typeof process.nextTick === 'function') {\n    // nodejs\n    return process.nextTick;\n  } else if (typeof setImmediate === 'function') {\n    // supporting browsers\n    return setImmediate;\n  } else {\n    // fallback\n    return function (fn) {\n      setTimeout(fn, 0);\n    };\n  }\n}();\n\nvar AsynccError = function (Error) {\n  function AsynccError(message, errors, errpos) {\n    Error.call(this, message);\n    Object.assign(this, {\n      name: 'AsynccError',\n      message: message,\n      errors: errors,\n      errpos: errpos,\n      stack: this.stack ||\n      /* istanbul ignore next */\n      new Error().stack\n    });\n  }\n\n  if (Error) AsynccError.__proto__ = Error;\n  AsynccError.prototype = Object.create(Error && Error.prototype);\n  AsynccError.prototype.constructor = AsynccError;\n  return AsynccError;\n}(Error);\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a task are passed no the next task.\n * Stops on errors and immediatelly calls optional `callback` in this case.\n *\n * @name compose\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type\n * `function (arg: any, cb: function)`\n * `arg` - an argument which is passed from one task to the other\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg: any, cb: function)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback `function(err: <Error>, res: any)`\n * @example\n * var c = compose(\n *   (res, cb) => { cb(null, res + 1) },\n *   (res, cb) => { cb('error', res * 2) }, // breaks here on first error\n *   (res, cb) => { cb(null, res + 3) },\n * )\n * c(2, function (err, res) {\n *   //> err = 'error'\n *   //> res = 6\n * })\n */\n\n\nfunction compose() {\n  var tasks = [],\n      len = arguments.length;\n\n  while (len--) {\n    tasks[len] = arguments[len];\n  }\n\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n\n  return function (arg, callback) {\n    var i = 0;\n\n    function run(err, res) {\n      var fn = tasks[i++];\n\n      if (err || !fn) {\n        callback && callback(err, res);\n      } else {\n        fn(res, run);\n      }\n    }\n\n    run(null, arg);\n  };\n}\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a **task** are passed to the next task.\n * Passed or thrown errors in tasks get trapped with\n * functions of arity 3 `function (err, res, cb)` called here **trap**.\n * In case that there is no previous error, a **trap** acts as \"no-op\".\n * In case that no **trap** is defined then the chain exits to an optional `callback`.\n *\n * @name connect\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type **task**\n * `function (arg: any, cb: function)` or **trap** `function (err: <Error>, arg: any, cb: function)` where\n * `arg` - an argument which is passed from one task to the other\n * `err` - a trapped error from previous tasks\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg, cb)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback function `function(err: <Error>, res: any)`\n * @example\n * var c = connect(\n *   (res, cb) => { cb(null, res + 1) },      // task\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - \"no-op\" here as there is no previous error\n *   (res, cb) => { cb(null, res * 2) }       // task\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 6\n * })\n *\n * @example <caption>With error traps</caption>\n * var c = connect(\n *   (res, cb) => { cb('error', res + 1) },   // task - error is passed to next task\n *   (res, cb) => { cb(null, res * 2) },      // task - \"no-op\", jumps over this task due to previous error\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - error gets trapped here (arity === 3)\n *   (res, cb) => { cb(null, res * 2) }       // task - continues\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 12\n * })\n *\n */\n\n\nfunction connect() {\n  var tasks = [],\n      len = arguments.length;\n\n  while (len--) {\n    tasks[len] = arguments[len];\n  }\n\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n\n  return function (arg, callback) {\n    var i = 0;\n    run(null, arg);\n\n    function run(err, res) {\n      var fn = tasks[i++];\n\n      try {\n        if (err) {\n          // search for next function of arity 3\n          while (fn && fn.length !== 3) {\n            fn = tasks[i++];\n          }\n\n          fn && fn(err, res, run);\n        } else {\n          // jump over all error traps\n          while (fn && fn.length > 2) {\n            fn = tasks[i++];\n          }\n\n          fn && fn(res, run); // step\n        }\n      } catch (e) {\n        run(e, res);\n      }\n\n      if (!fn) {\n        callback && callback(err, res);\n      }\n    }\n  };\n}\n/**\n* Run `task` one or more times until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name doUntil\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doUntil(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index >= 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction doUntil(task, test, callback) {\n  var i = 0;\n\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n\n  run();\n}\n/**\n* Run `task` one or more times until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name doWhilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doWhilst(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index < 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction doWhilst(task, test, callback) {\n  doUntil(task, function (n) {\n    return !test(n);\n  }, callback);\n}\n\nfunction parallel$1(limit, length, run, opts, callback) {\n  if (opts === void 0) opts = {};\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  limit = Math.abs(limit || length);\n  var errpos = [];\n  var errors = new Array(length).fill();\n  var results = new Array(length).fill();\n  var i = 0;\n  var l = length;\n  var done = 0;\n\n  if (l === 0) {\n    _final();\n\n    return;\n  }\n\n  if (opts.timeout) {\n    setTimeout(function () {\n      /* istanbul ignore else */\n      if (l) {\n        _final('err_timeout');\n      }\n    }, opts.timeout);\n  }\n\n  limit = limit < length ? limit : length;\n\n  while (i < limit) {\n    run(i++, cb);\n  }\n\n  function _final(errMsg) {\n    if (done++) {\n      return;\n    }\n\n    var err = null;\n\n    if (errpos.length || errMsg) {\n      err = new AsynccError(errMsg || 'err', errors, errpos);\n    }\n\n    callback && callback(err, results);\n  }\n\n  function cb(j, err, res) {\n    results[j] = res;\n    errors[j] = err;\n\n    if (err) {\n      errpos.push(j);\n\n      if (opts.bail) {\n        _final('err_bail');\n\n        return;\n      }\n    }\n\n    l--;\n\n    if (i < length) {\n      run(i++, cb);\n    } else if (!l) {\n      _final();\n    }\n  }\n}\n/**\n* Run `items` on async `task` function in parallel limited to `limit` parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name eachLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* eachLimit(2, [1, 2, 3, 4],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null, 'error']\n*     //> err.errpos = [1, 3]\n*     //> res = [1, 4, 5, 7]\n*   }\n* )\n*/\n\n\nfunction eachLimit(limit, items, task, opts, callback) {\n  function run(j, cb) {\n    task(items[j], function (err, res) {\n      cb(j, err, res);\n    }, j);\n  }\n\n  parallel$1(limit, items.length, run, opts, callback);\n}\n/**\n* Run `items` on async `task` function in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name each\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* each([1, 2, 3],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null]\n*     //> err.errpos = [1]\n*     //> res = [1, 4, 5]\n*   }\n* )\n*/\n\n\nfunction each(items, task, opts, callback) {\n  eachLimit(0, items, task, opts, callback);\n}\n/**\n * Run `items` on async `task` function in series. Stops at the first error encountered.\n *\n * @name eachSeries\n * @memberOf module:serial\n * @static\n * @method\n * @param {Array<any>} items - Array of items\n * @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n * @param {Function} [callback] - optional callback `function (errors: <Error>, result: Array<any>)`\n * @example\n * eachSeries([1, 2, 3],\n *   (item, cb, index) => {\n *     setImmediate(() => {\n *       cb(index % 2 ? null : 'error', item + index)\n *     })\n *   }, (err, res) => {\n *     //> err = 'error'\n *     //> res = [1, 4]\n *   }\n * )\n */\n\n\nfunction eachSeries(items, task, callback) {\n  var length = items.length;\n  var results = [];\n  var i = 0;\n\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n\n  run();\n\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else  */\n\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(items[i], cb, i++);\n  }\n}\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* This method is similar to {@link module:serial.connect|connect} but allows adding `tasks` on the go through chaining.\n*\n* @name NoPromise\n* @class\n* @param {Any} arg - initial argument which is passed to first chain\n* @example <caption>Normal usage</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb(null, res)\n* }).end((err, res) => {\n*   //> err = null\n*   //> res = [1, 2]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Catch errors</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb('err1', res)             // <-- cause an error\n* }).catch((err, res, cb) => {  // catches err1\n*   res.push(err)\n*   cb(null, res)               // <-- continue normally\n* }).then((res, cb) => {\n*   res.push(3)\n*   cb(null, res)\n* }).catch((err, res, cb) => {  // jumps over, as there is no error in the chain\n*   res.push(4)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(5)\n*   cb('err2', res)             // <-- next error\n* }).end((err, res) => {\n*   //> err = 'err2'\n*   //> res = [1, 2, 'err1', 3, 5]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Deferred usage</caption>\n* var arr = []\n* // creates a new instance passing `arr`\n* var n = new NoPromise(arr)\n* // execute the first async method\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* })\n* // take a time off\n* setTimeout(() => {\n*   // continue processing\n*   n.then((res, cb) => {\n*     res.push(2)\n*     cb(null, res)\n*   }).end((err, res) => {\n*     //> err = null\n*     //> res = [1, 2]\n*     //> (arr ==== res) = true\n*   })\n* }, 10)\n*/\n\n\nfunction NoPromise(arg) {\n  this._tasks = [];\n  this.result = arg;\n  this.error = undefined;\n  this._lock = false;\n}\n\nNoPromise.prototype = {\n  /**\n   * runs the next function\n   * @private\n   */\n  _run: function _run() {\n    var this$1$1 = this;\n\n    if (this._lock) {\n      return;\n    }\n\n    this._lock = true;\n\n    var task = this._tasks.shift();\n\n    var tstType = this.error ? ['catch', 'end'] : ['then', 'end'];\n\n    while (task && !~tstType.indexOf(task.type)) {\n      task = this._tasks.shift();\n    }\n\n    if (task) {\n      var cb = function cb(err, res) {\n        this$1$1.error = err;\n        this$1$1.result = res || this$1$1.result;\n        this$1$1._lock = false;\n\n        this$1$1._run();\n      };\n\n      var fn = task.fn;\n\n      if (task.type === 'end') {\n        // .end\n        fn(this.error, this.result);\n      } else {\n        try {\n          if (task.type === 'catch') {\n            // .catch\n            fn(this.error, this.result, cb);\n          } else {\n            // .then\n            fn(this.result, cb);\n          }\n        } catch (e) {\n          cb(e);\n        }\n      }\n    } else {\n      this._lock = false;\n    }\n  },\n\n  /**\n   * Chain the next async function\n   * @param {Function} task - async function `function (res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  then: function then(task) {\n    this._tasks.push({\n      type: 'then',\n      fn: task\n    });\n\n    this._run();\n\n    return this;\n  },\n\n  /**\n   * Catch any previous errors from the chain\n   * @param {Function} trap - async function `function (err: <Error>, res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  \"catch\": function _catch(trap) {\n    this._tasks.push({\n      type: 'catch',\n      fn: trap\n    });\n\n    this._run();\n\n    return this;\n  },\n\n  /**\n   * End the chain\n   * @param {Function} callback - `function (err: <Error>, res: any)`\n   */\n  end: function end(callback) {\n    this._tasks.push({\n      type: 'end',\n      fn: callback\n    });\n\n    this._run();\n  }\n};\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* See full API here {@link NoPromise}.\n*\n* @name noPromise\n* @memberOf module:serial\n* @static\n* @method\n* @param {Any} arg - initial argument which is passed to first chain\n* @return {NoPromise}\n*/\n\nfunction noPromise(arg) {\n  return new NoPromise(arg);\n}\n/**\n* Run `tasks` callback functions in parallel limited to `limit` parallel\n* running tasks.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallelLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n*\n* @example\n* // runs 2 tasks in parallel\n* parallelLimit(2, [\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errorpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\n\n\nfunction parallelLimit(limit, tasks, opts, callback) {\n  function run(j, cb) {\n    tasks[j](function (err, res) {\n      cb(j, err, res);\n    });\n  }\n\n  parallel$1(limit, tasks.length, run, opts, callback);\n}\n/**\n* Run `tasks` callback functions in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallel\n* @memberOf module:parallel\n* @static\n* @method\n\n* @param {Array<Function>} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* parallel([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\n\n\nfunction parallel(tasks, opts, callback) {\n  parallelLimit(0, tasks, opts, callback);\n}\n/**\n* Creates an Array which adds items by priority\n*/\n\n\nfunction PrioArray() {\n  this.reset();\n}\n\nPrioArray.prototype = {\n  /**\n  * length of Array\n  */\n  get length() {\n    return this.items.length;\n  },\n\n  /**\n  * shift item from array\n  * @return {Any} item\n  */\n  shift: function shift() {\n    return (this.items.shift() ||\n    /* istanbul ignore next */\n    {}).item;\n  },\n\n  /**\n  * push `item` to Array using priority\n  * @param {Any} item\n  * @param {Number} [prio=Infinity] - priority `0 ... Infinity` - lower values have higher priority\n  */\n  push: function push(item, prio) {\n    var items = this.items;\n\n    if (typeof prio !== 'number') {\n      prio = Infinity;\n      items.push({\n        prio: prio,\n        item: item\n      });\n    } else {\n      var found;\n      prio = Math.abs(prio);\n\n      for (var i = 0; i < items.length; i++) {\n        if (prio < items[i].prio) {\n          items.splice(i, 0, {\n            prio: prio,\n            item: item\n          });\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        items.push({\n          prio: prio,\n          item: item\n        });\n      }\n    }\n\n    return this;\n  },\n\n  /**\n  * unshift `item` to Array using priority\n  * @param {Any} item\n  */\n  unshift: function unshift(item) {\n    this.items.unshift({\n      prio: 0,\n      item: item\n    });\n    return this;\n  },\n\n  /**\n  * removes all items in the Array\n  */\n  reset: function reset() {\n    this.items = [];\n  }\n};\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* @name Queue\n* @methodOf: module:parallel\n* @class\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @example <caption>Default usage</caption>\n* var arr = []\n* var q = new Queue((item, cb) => {\n*   arr.push(item)\n*   cb(null, item)\n* })\n* // push item \"one\" at end of queue\n* q.push('one', (err, res) => {\n*   console.log(res + ' finished')\n* })\n* // add item \"two\" at start of queue\n* q.unshift('two', () => {\n*   console.log('two finished')\n* })\n* // called when all items in queue where processed\n* q.drain(() => {\n*   console.log(arr)\n*   //> arr = ['one', 'two']\n* })\n* @example <caption>Using priorities</caption>\n* let arr = []\n*\n* let q = new Queue(function (item, cb) {\n*   arr.push(item)\n*   cb()\n* }, 2)\n*\n* q.concat([100, 101, 102], 3) // priority = 3 - last (but 2 items already processed)\n* q.concat([0, 1, 2], 1)       // priority = 1 - first\n* q.concat([10, 11, 12], 2)    // priority = 2 - second\n*\n* q.drain(() => {\n*   //> arr = [ 100, 101, 0, 1, 2, 10, 11, 12, 102 ])\n* })\n*/\n\nfunction Queue(task, concurrency) {\n  this._task = task;\n  this._concurrency = Math.abs(concurrency || 1);\n  this._worker = 0;\n  this._paused = false;\n  this._items = new PrioArray();\n}\n\nQueue.prototype = {\n  /**\n  * process items in queue\n  * @private\n  */\n  _run: function _run() {\n    var this$1$1 = this;\n    var ref = this;\n    var _items = ref._items;\n    var _drain = ref._drain;\n    this._worker -= 1;\n\n    if (_items.length === 0) {\n      if (this._worker <= 0) {\n        this._worker = 0;\n        _drain && _drain();\n      }\n    } else {\n      this._worker += 1;\n\n      var ref$1 = _items.shift();\n\n      var item = ref$1[0];\n      var cb = ref$1[1];\n\n      this._task(item, function (err, res) {\n        cb && cb(err, res);\n\n        _setImmediate(function () {\n          // prevent RangeError: Maximum call stack size exceeded for sync tasks\n          this$1$1._run();\n        });\n      });\n    }\n  },\n\n  /**\n  * start processing queue or add workers up to concurrency\n  * @private\n  */\n  _start: function _start() {\n    while (!this._paused && this._worker < Math.min(this._concurrency, this._items.length)) {\n      this._worker += 1;\n\n      this._run();\n    }\n\n    return this;\n  },\n\n  /**\n  * Check if queue is paused\n  * @return {Boolean} `true` if paused\n  */\n  get paused() {\n    return this._paused;\n  },\n\n  /**\n  * Check if queue is idle - means no items in queue and no workers running\n  * @return {Boolean} `true` if idle\n  */\n  get idle() {\n    return !this.length && this._worker === 0;\n  },\n\n  /**\n  * Number of items waiting in the queue to get processed\n  * @return {Number} number of items in queue\n  */\n  get length() {\n    return this._items.length;\n  },\n\n  /**\n  * Pause processing\n  * @return {this} for chaining\n  */\n  pause: function pause() {\n    this._paused = true;\n    return this;\n  },\n\n  /**\n  * Resume processing\n  * @return {this} for chaining\n  */\n  resume: function resume() {\n    this._paused = false;\n    return this._start();\n  },\n\n  /**\n  * Reset the queue by removing all pending items from the queue\n  * @return {this} for chaining\n  */\n  reset: function reset() {\n    this._items.reset();\n\n    return this;\n  },\n\n  /**\n  * Number of items being processed\n  * @return {Number} number of items processed\n  */\n  running: function running() {\n    return this._worker;\n  },\n\n  /**\n  * push `item` onto queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  push: function push(item, callback, priority) {\n    return this.concat([item], callback, priority);\n  },\n\n  /**\n  * concat `items` onto queue - fills the queue first with `items` before starting processing\n  * @param {Any[]} items\n  * @param {Function} [callback] - optional callback if single item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  concat: function concat(items, callback, priority) {\n    var this$1$1 = this;\n\n    if (typeof callback === 'number') {\n      priority = callback;\n      callback = undefined;\n    }\n\n    items.forEach(function (item) {\n      this$1$1._items.push([item, callback], priority);\n    });\n    return this._start();\n  },\n\n  /**\n  * put `item` at the very beginnning of the queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @return {this} for chaining\n  */\n  unshift: function unshift(item, callback) {\n    this._items.unshift([item, callback]);\n\n    return this._start();\n  },\n\n  /**\n  * @param {Function} [callback] - optional callback called if all queue items got processed\n  * @return {this} for chaining\n  */\n  drain: function drain(callback) {\n    this._drain = callback;\n    return this;\n  }\n};\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* See full API here {@link Queue}.\n*\n* @name queue\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @return {Queue}\n*/\n\nfunction queue(task, concurrency) {\n  return new Queue(task, concurrency);\n}\n/**\n* @private\n*/\n\n\nfunction _times(num, opts) {\n  opts = opts || {};\n  var fn = _setImmediate;\n  var lag = 0;\n  var times = num;\n\n  if (typeof num !== 'number') {\n    times = num.times;\n    lag = num.lag || 0;\n  }\n\n  times = times || opts.times || 0;\n\n  if (lag) {\n    fn = setTimeout;\n  }\n\n  return {\n    times: times,\n    lag: lag,\n    fn: fn\n  };\n}\n/**\n* Run `task` max. `times` times. Stops at first iteration where no error is returned.\n*\n* Calls `callback` if `times` is reached or `task` returned no error.\n*\n* @name retry\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - retry max. `times` times - default=2\n* @param {Number} [times.times=2] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n* @example\n* let arr = []\n* retry({times: 3, lag: 100}, // max. 3 retries with 100ms time-lag between retries\n*   (cb, index) => { // task\n*     let err = index < 2 ? new Error() : null\n*     arr.push(index)\n*     cb(err, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 2\n*     //> arr = [0, 1, 2]\n*   }\n* )\n*/\n\n\nfunction retry(num, task, callback) {\n  var i = 0;\n\n  var ref = _times(num, {\n    times: 2\n  });\n\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n  run();\n\n  function cb(err, res) {\n    if (!err || i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n}\n/**\n* Run `tasks` callback functions in series\n* The function breaks after the first error encountered and calls optional\n* `callback` function\n*\n* @name series\n* @memberOf module:serial\n* @static\n* @method\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: Error, res: Array<any>)`\n*\n* @example\n* series([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) }, // breaks on first error\n*   (cb) => { cb(null, 3) },\n* ], (err, res) => {\n*   //> err = 'error'\n*   //> res = [1, 2]\n* })\n*/\n\n\nfunction series(tasks, callback) {\n  var length = tasks.length;\n  var results = [];\n  var i = 0;\n\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n\n  run();\n\n  function run() {\n    tasks[i++](cb);\n  }\n\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else */\n\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n}\n/**\n* Run `task` repeatedly until number `times` is reached.\n*\n* Stops at the first error encountered.\n* An optional `lag` between retries may be used.\n*\n* @name times\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - runs `times` times. If `times < 0` then \"times\" cycles endlessly until an error occurs.\n* @param {Number} [times.times=0] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: Array<any>)`\n*\n* @example\n* let arr = []\n* times({times: 4, lag: 100}, // 4 times with 100ms time-lag between retries\n*   (cb, index) => {\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction times(num, task, callback) {\n  var i = 0;\n\n  var ref = _times(num);\n\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n\n  if (times) {\n    run();\n  } else {\n    callback && callback();\n  }\n\n  function cb(err, res) {\n    if (err || times > 0 && i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n}\n/**\n* Run `task` repeatedly until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name until\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* until(\n*   (index) => {        // test\n*     return index >= 4\n*   }, (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction until(test, task, callback) {\n  var i = 0;\n\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n\n  function run() {\n    task(cb, i++);\n  }\n\n  if (!test(i)) {\n    run();\n  } else {\n    callback && callback();\n  }\n}\n/**\n* Run `task` repeatedly until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name whilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* whilst(\n*   (index) => (index < 4), // test\n*   (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\n\n\nfunction whilst(test, task, callback) {\n  until(function (n) {\n    return !test(n);\n  }, task, callback);\n}\n/**\n* Serial execution patterns\n* @module serial\n*/\n\n\nvar index = {\n  _setImmediate: _setImmediate,\n  AsynccError: AsynccError,\n  compose: compose,\n  connect: connect,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  each: each,\n  eachLimit: eachLimit,\n  eachSeries: eachSeries,\n  noPromise: noPromise,\n  NoPromise: NoPromise,\n  parallel: parallel,\n  parallelLimit: parallelLimit,\n  queue: queue,\n  Queue: Queue,\n  retry: retry,\n  series: series,\n  times: times,\n  until: until,\n  whilst: whilst\n};\n\n\n//# sourceURL=webpack:///../../node_modules/asyncc/dist/index.es.js?");

/***/ }),

/***/ "../../node_modules/fast-safe-stringify/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/fast-safe-stringify/index.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nmodule.exports = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = '[...]';\nvar CIRCULAR_REPLACE_NODE = '[Circular]';\nvar arr = [];\nvar replacerStack = [];\n\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  };\n} // Regular stringify\n\n\nfunction stringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options);\n  var res;\n\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, {\n        value: replace\n      });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\n\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!\n\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n\n    stack.pop();\n  }\n} // Stable-stringify\n\n\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;\n  var res;\n\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n\n    try {\n      if (typeof val.toJSON === 'function') {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!\n\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n\n    stack.pop();\n  }\n} // wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\n\n\nfunction replaceGetterValues(replacer) {\n  replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {\n    return v;\n  };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    return replacer.call(this, key, val);\n  };\n}\n\n//# sourceURL=webpack:///../../node_modules/fast-safe-stringify/index.js?");

/***/ }),

/***/ "../../node_modules/ms/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ms/index.js ***!
  \**************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///../../node_modules/ms/index.js?");

/***/ }),

/***/ "../../src/Format.js":
/*!***************************!*\
  !*** ../../src/Format.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _format = __webpack_require__(/*! ./quick-format.js */ \"../../src/quick-format.js\");\n\nvar fastStringify = __webpack_require__(/*! fast-safe-stringify */ \"../../node_modules/fast-safe-stringify/index.js\");\n\nmodule.exports = Format;\n/**\n * @param {object} [opts]\n * @param {number} [opts.spaces] - JSON.stringify spaces\n */\n\nfunction Format() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.assign(this, {\n    opts: opts\n  });\n\n  this._formatOpts();\n}\n\nFormat.prototype = {\n  get spaces() {\n    return this.opts.spaces;\n  },\n\n  set spaces(spaces) {\n    this.opts.spaces = spaces;\n\n    this._formatOpts();\n  },\n\n  _formatOpts: function _formatOpts() {\n    var _this = this;\n\n    this.formatOpts = {\n      stringify: function stringify(o) {\n        return fastStringify(o, null, _this.opts.spaces);\n      }\n    };\n  },\n  stringify: function stringify() {\n    return fastStringify.apply(void 0, arguments);\n  },\n\n  /**\n   * formats arguments like `util.format`\n   * @param {...Any} arguments list - args[0] may contain \"%\" formatters\n   * @return {Array} first is formatted message, other args may follow\n   */\n  format: function format(fmt, args, obj) {\n    return _format(fmt, args, this.formatOpts, obj);\n  }\n};\n\n//# sourceURL=webpack:///../../src/Format.js?");

/***/ }),

/***/ "../../src/LogBase.js":
/*!****************************!*\
  !*** ../../src/LogBase.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar Format = __webpack_require__(/*! ./Format.js */ \"../../src/Format.js\");\n\nvar _require = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\"),\n    toNumLevel = _require.toNumLevel,\n    adjustLevel = _require.adjustLevel,\n    LEVELS = _require.LEVELS,\n    LOG = _require.LOG,\n    INFO = _require.INFO,\n    FATAL = _require.FATAL;\n\nvar Namespaces = __webpack_require__(/*! ./Namespaces.js */ \"../../src/Namespaces.js\");\n\nvar noop = function noop() {};\n\nvar time = {\n  epoch: function epoch() {\n    return Date.now();\n  },\n  unix: function unix() {\n    return Date.now() / 1000 | 0;\n  },\n  iso: function iso() {\n    return new Date().toISOString();\n  }\n};\n\nfunction LogBase(name, opts) {\n  Object.assign(this, {\n    name: name,\n    opts: opts,\n    _enabled: {},\n    formatter: new Format(opts)\n  });\n  this.serializers = Object.entries(this.opts.serializers || {}).reduce(function (o, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        val = _ref2[1];\n\n    if (typeof val === 'function') {\n      o = o || {};\n      o[key] = val;\n    }\n\n    return o;\n  }, null);\n  this._timeF = time[opts.timestamp];\n  this._time = this._timeF ? this._timeF : noop;\n  this.enable();\n}\n\nLogBase.prototype = {\n  enable: function enable(namespaces) {\n    var _this = this;\n\n    namespaces = namespaces || this.opts.namespaces;\n    var namespace = new Namespaces(namespaces);\n    this._enabled = {}; // reset\n\n    var level = namespace.isEnabled(this.name, this.opts.level);\n    var active = level ? LEVELS[adjustLevel(level, INFO)] : [];\n    LEVELS.TRACE.forEach(function (level) {\n      // loop over all levels\n      var nlevel = _this.opts.levelNumbers ? toNumLevel(level) : level;\n      var llevel = level.toLowerCase();\n\n      if (active.includes(level)) {\n        _this._enabled[level] = true;\n        _this[llevel] = level === FATAL ? function (fmt) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          var str = _this._log(nlevel, fmt, args);\n\n          _this.flush && _this.flush();\n          return str;\n        } : function (fmt) {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          return _this._log(nlevel, fmt, args);\n        };\n      } else {\n        _this[llevel] = noop;\n      }\n    });\n    var nLOG = this.opts.levelNumbers ? toNumLevel(LOG) : LOG;\n\n    this.log = function (fmt) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      return _this._log(nLOG, fmt, args);\n    };\n  },\n\n  get enabled() {\n    var _this2 = this;\n\n    return this._enabled._cache || (this._enabled._cache = LEVELS.TRACE.reduce(function (o, level) {\n      o[level] = o[level.toLowerCase()] = !!_this2._enabled[level];\n      return o;\n    }, {}));\n  },\n\n  diff: function diff() {\n    var curr = Date.now();\n    var prev = this._prev || curr;\n    this._prev = curr;\n    return curr - prev;\n  },\n\n  /**\n   * @return {object} json object\n   */\n  _formatJson: function _formatJson(level, fmt) {\n    var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var other = {};\n    var msg = this.formatter.format(fmt, args, other) || undefined;\n\n    var o = _objectSpread({\n      level: level,\n      time: this._time(),\n      name: this.name,\n      msg: msg,\n      pid: this.pid,\n      hostname: this.hostname,\n      diff: this.diff()\n    }, other);\n\n    return o;\n  },\n  _applySerializers: function _applySerializers(obj) {\n    var o = {};\n\n    for (var key in obj) {\n      var value = obj[key];\n\n      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n        if (this.serializers && this.serializers[key]) {\n          o[key] = this.serializers[key](value);\n        } else {\n          o[key] = value;\n        }\n      }\n    }\n\n    return o;\n  },\n\n  /* c8 ignore next */\n  _serverinfo: function _serverinfo() {},\n\n  /* c8 ignore next 3 */\n  _log: function _log() {\n    throw new Error('needs implementation');\n  }\n};\nmodule.exports = LogBase;\n\n//# sourceURL=webpack:///../../src/LogBase.js?");

/***/ }),

/***/ "../../src/Namespaces.js":
/*!*******************************!*\
  !*** ../../src/Namespaces.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n * @see https://github.com/visionmedia/debug\n */\nvar _require = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\"),\n    TRACE = _require.TRACE,\n    DEBUG = _require.DEBUG,\n    INFO = _require.INFO,\n    WARN = _require.WARN,\n    ERROR = _require.ERROR,\n    FATAL = _require.FATAL,\n    OFF = _require.OFF;\n\nvar LEVELS = [TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF];\nvar LEVELS_REGEX = RegExp(\"^(\".concat(LEVELS.join('|'), \"):\"), 'i');\nmodule.exports = Namespaces;\n\nfunction Namespaces(namespaces) {\n  this.enable(namespaces);\n}\n\nNamespaces.prototype = {\n  enable: function enable(namespaces) {\n    this.skips = [];\n    this.names = [];\n    var splited = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\n    var _iterator = _createForOfIteratorHelper(splited),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _namespace = _step.value;\n        if (!_namespace) continue; // ignore empty strings\n\n        var _this$_namespaceNLeve = this._namespaceNLevel(_namespace),\n            namespace = _this$_namespaceNLeve.namespace,\n            level = _this$_namespaceNLeve.level;\n\n        if (namespace[0] === '-') {\n          this.skips.push({\n            re: new RegExp('^' + namespace.substr(1) + '$')\n          });\n        } else {\n          this.names.push({\n            re: new RegExp('^' + namespace + '$'),\n            level: level\n          });\n        }\n      } // sort names by levels\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.names = this.names.sort(function (a, b) {\n      return LEVELS.indexOf(a.level) - LEVELS.indexOf(b.level);\n    });\n  },\n\n  /* c8 ignore next 3 */\n  disable: function disable() {\n    this.enable('');\n  },\n  isEnabled: function isEnabled(name, level) {\n    if (name === '*') {\n      return level || 'DEBUG';\n    }\n\n    if (!this.names.length) {\n      return level;\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(this.skips),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _skip = _step2.value;\n\n        if (_skip.re.test(name)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(this.names),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _name = _step3.value;\n\n        if (_name.re.test(name)) {\n          return _name.level || level || 'DEBUG';\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _namespaceNLevel: function _namespaceNLevel(_namespace) {\n    var level = (LEVELS_REGEX.exec(_namespace) || [])[1];\n\n    var namespace = _namespace.replace(LEVELS_REGEX, '').replace(/\\*/g, '.*?');\n\n    return {\n      namespace: namespace,\n      level: level\n    };\n  }\n};\n\n//# sourceURL=webpack:///../../src/Namespaces.js?");

/***/ }),

/***/ "../../src/browser.js":
/*!****************************!*\
  !*** ../../src/browser.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var asyncc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asyncc */ \"../../node_modules/asyncc/dist/index.es.js\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ms */ \"../../node_modules/ms/index.js\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ms__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"../../src/utils.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _LogBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LogBase.js */ \"../../src/LogBase.js\");\n/* harmony import */ var _LogBase_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_LogBase_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _wrapConsole_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrapConsole.js */ \"../../src/wrapConsole.js\");\n/* harmony import */ var _wrapConsole_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_wrapConsole_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _serializers_err_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serializers/err.js */ \"../../src/serializers/err.js\");\n/* harmony import */ var _serializers_err_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_serializers_err_js__WEBPACK_IMPORTED_MODULE_5__);\nvar _excluded = [\"level\", \"name\", \"time\", \"msg\", \"diff\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* global navigator window document Image chrome */\n\n\n\n\n\n\nvar COLOR_RESET = 'color:inherit';\n/**\n * global log options\n */\n\nvar options = {\n  level: _utils__WEBPACK_IMPORTED_MODULE_2__.WARN,\n  namespaces: undefined,\n  colors: true,\n  // apply coloring to browser console\n  url: undefined // [optional] url to report errors\n\n};\n/**\n * get storage\n * @private\n */\n\nvar storage = function storage() {\n  try {\n    return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined' ? chrome.storage.local : window.localStorage;\n  } catch (err) {\n    // istanbul ignore next\n    return {};\n  }\n};\n/**\n * check if console colors are supported\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n * @private\n */\n\n\nvar supportsColors = function supportsColors() {\n  var tmp;\n  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent; // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n\n  var isElectron = typeof window !== 'undefined' && (tmp = window.process) && tmp.type === 'renderer'; // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n  var isReactNative = typeof document !== 'undefined' && (tmp = document.documentElement) && (tmp = tmp.style) && tmp.WebkitAppearance; // is firebug? http://stackoverflow.com/a/398120/376773\n\n  var isFireBug = typeof window !== 'undefined' && (tmp = window.console) && (tmp.firebug || tmp.exception && tmp.table);\n\n  if (isElectron) {\n    // istanbul ignore next\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (/(edge|trident)\\/(\\d+)/i.exec(userAgent)) {\n    // istanbul ignore next\n    return false;\n  }\n\n  return !!(isReactNative || isFireBug || /firefox\\/(\\d+)/i.exec(userAgent) && parseInt(RegExp.$1, 10) >= 31 || /applewebkit\\/(\\d+)/i.exec(userAgent));\n};\n/**\n * creates a new logger for the browser\n * @constructor\n * @param {String} name - namespace of Logger\n */\n\n\nfunction Log(name, opts) {\n  if (!(this instanceof Log)) return new Log(name, opts);\n\n  var _storage = storage();\n\n  Object.assign(options, (0,_utils__WEBPACK_IMPORTED_MODULE_2__.inspectOpts)(_storage), (0,_utils__WEBPACK_IMPORTED_MODULE_2__.inspectNamespaces)(_storage));\n  options.colors = options.colors === false ? false : supportsColors();\n  var serializers = Object.assign({}, options.serializers, opts && opts.serializers);\n  _LogBase_js__WEBPACK_IMPORTED_MODULE_3___default().call(this, name, Object.assign({}, options, opts, {\n    serializers: serializers\n  }));\n\n  var colorFn = function colorFn(c) {\n    return \"color:\".concat(c);\n  };\n\n  this.color = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.selectColor)(name, colorFn);\n  this.levColors = (0,_utils__WEBPACK_IMPORTED_MODULE_2__.levelColors)(colorFn);\n  this.queue = new asyncc__WEBPACK_IMPORTED_MODULE_0__.Queue(this._sendLog.bind(this), 3);\n}\n\nObject.setPrototypeOf(Log.prototype, (_LogBase_js__WEBPACK_IMPORTED_MODULE_3___default().prototype));\nObject.assign(Log.prototype, {\n  /**\n   * render arguments to console.log\n   * @public\n   * @param {Array} args - console.log arguments\n   * @param {String} level - level of log line (might be used for custom Logger which uses different streams per level)\n   * @return {String}\n   */\n  render: function render(args) {\n    var _console;\n\n    (_console = console).log.apply(_console, _toConsumableArray(args)); // eslint-disable-line no-console\n\n\n    return args;\n  },\n\n  /**\n   * send log to server\n   * @param {String|Object} level - log level\n   * @param {String|Any} fmt - log level\n   * @param {Array} args - log arguments\n   */\n  send: function send(level, fmt, args) {\n    var obj;\n\n    if (_typeof(level) === 'object') {\n      obj = level;\n    } else {\n      var uns = this._formatJson(level, fmt, args);\n\n      obj = this._applySerializers(uns);\n    }\n\n    obj.userAgent = navigator.userAgent;\n    var str = this.formatter.stringify(obj);\n    this.queue.push(str);\n  },\n\n  /**\n   * format log arguments\n   * @private\n   */\n  _log: function _log(level, fmt, args) {\n    var uns = this._formatJson(level, fmt, args);\n\n    var obj = this._applySerializers(uns);\n\n    var _args = this._format(obj);\n\n    var res = this.render(_args, level);\n\n    if (this.opts.url) {\n      this.send(obj);\n    }\n\n    return res;\n  },\n\n  /**\n   * format arguments for console.log\n   * @private\n   * @return {Array} args for console.log\n   */\n  _format: function _format(_ref) {\n    var level = _ref.level,\n        name = _ref.name,\n        time = _ref.time,\n        _ref$msg = _ref.msg,\n        msg = _ref$msg === void 0 ? '' : _ref$msg,\n        diff = _ref.diff,\n        other = _objectWithoutProperties(_ref, _excluded);\n\n    var color = this.color;\n    var args = [];\n    var hasOther = Object.keys(other).length;\n    args[0] = [this._color(level), this._color(name), msg, hasOther ? '%O' : undefined, this._color('+' + ms__WEBPACK_IMPORTED_MODULE_1___default()(diff))].filter(function (s) {\n      return s !== undefined;\n    }).join(' ');\n    if (hasOther) args.push(other);\n\n    if (this.opts.colors) {\n      args.splice(1, 0, color + ';font-weight:bold', COLOR_RESET);\n      args.splice(1, 0, this.levColors[level], COLOR_RESET);\n    }\n\n    if (this.opts.colors) {\n      var idx = 0;\n      var lastC;\n      args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        idx++;\n\n        if (format === 'c') {\n          lastC = idx;\n        }\n\n        return match;\n      });\n      args.splice(lastC - 1, 0, color, COLOR_RESET);\n    }\n\n    return args;\n  },\n\n  /**\n   * transfer log to server via zero pixel image request\n   */\n  _sendLog: function _sendLog(str, cb) {\n    var img = new Image();\n\n    var done = function done() {\n      return cb();\n    };\n\n    img.onload = done;\n    img.onerror = done;\n    img.onabort = done;\n    img.src = this.opts.url + '?id=' + (0,_utils__WEBPACK_IMPORTED_MODULE_2__.random)(6) + '&log=' + encodeURIComponent(str);\n  },\n\n  /**\n   * Add colors, style to string\n   * @private\n   */\n  _color: function _color(str) {\n    return this.opts.colors ? \"%c\".concat(str, \"%c\") : str;\n  }\n});\n/**\n * Apply (and get) global options\n * @param {object} [opts] - changed options\n * @return {object} global options\n */\n\nLog.options = function (opts) {\n  if (!opts) return Object.assign({}, options);\n  Object.assign(options, opts, {\n    colors: opts.colors === false ? false : supportsColors()\n  });\n  return options;\n};\n/**\n * save options in `localStorage`\n */\n\n\nLog.save = function () {\n  var _storage = storage();\n\n  Log.reset();\n  (0,_utils__WEBPACK_IMPORTED_MODULE_2__.saveOpts)(_storage, options);\n};\n/**\n * reset saved options\n */\n\n\nLog.reset = function () {\n  var _storage = storage();\n\n  Object.keys(_storage).forEach(function (key) {\n    if (/^(DEBUG|DEBUG_.*)$/i.test(key)) {\n      _storage.removeItem(key);\n    }\n  });\n};\n/**\n * wrap console logging functions like\n * console.log, console.info, console.warn, console.error\n * @param {string} [name='console']\n * @param {object} opts - see Log.options\n * @param {string} [opts.level4log='log'] - log level for console.log\n * @return {function} unwrap function\n */\n\n\nLog.wrapConsole = function () {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'console';\n  var opts = arguments.length > 1 ? arguments[1] : undefined;\n  var log = new Log(name, opts);\n  return _wrapConsole_js__WEBPACK_IMPORTED_MODULE_4___default()(log, opts);\n};\n\nLog.serializers = {\n  err: (_serializers_err_js__WEBPACK_IMPORTED_MODULE_5___default())\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Log);\n\n//# sourceURL=webpack:///../../src/browser.js?");

/***/ }),

/***/ "../../src/quick-format.js":
/*!*********************************!*\
  !*** ../../src/quick-format.js ***!
  \*********************************/
/***/ ((module) => {

eval("var _excluded = [\"name\", \"level\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @credits quick-format-unescaped\n * @license The MIT License (MIT)\n * @copyright Copyright (c) 2016-2019 David Mark Clements\n */\nfunction tryStringify(o) {\n  try {\n    return JSON.stringify(o);\n  } catch (e) {\n    return '\"[Circular]\"';\n  }\n}\n\nmodule.exports = format;\n\nfunction format(f, args, opts) {\n  var obj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var ss = opts && opts.stringify || tryStringify;\n  var argLen = args.length;\n  var a = 0;\n  var str = '';\n\n  var type = _typeof(f);\n\n  var procObj = function procObj(val) {\n    if (Array.isArray(val)) {\n      Object.assign(obj, {\n        arr: val\n      });\n    } else if (val instanceof Error) {\n      // } else if (val.stack && val.message && val.name) {\n      if (!str) str = val.message;\n      Object.assign(obj, {\n        err: val\n      });\n    } else {\n      var name = val.name,\n          level = val.level,\n          other = _objectWithoutProperties(val, _excluded);\n\n      Object.assign(obj, other);\n    }\n  };\n\n  if (type === 'function') {\n    str = toFunctionSting(f.name);\n  } else if (type === 'object' && f !== null) {\n    str = f.msg || '';\n    procObj(f);\n  } else if (type !== 'string') {\n    str = String(f);\n  } else if (type === 'string') {\n    if (argLen === 0) return f;\n    var lastPos = -1;\n    var flen = f && f.length || 0;\n\n    for (var i = 0; i < flen;) {\n      if (f.charCodeAt(i) === 37 && i + 1 < flen) {\n        lastPos = lastPos > -1 ? lastPos : 0;\n\n        switch (f.charCodeAt(i + 1)) {\n          case 100: // 'd'\n\n          case 102:\n            // 'f'\n            if (a >= argLen) {\n              break;\n            }\n\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n\n            if (args[a] == null) break;\n            str += Number(args[a]);\n            lastPos = i = i + 2;\n            break;\n\n          case 105:\n            // 'i'\n            if (a >= argLen) {\n              break;\n            }\n\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n\n            if (args[a] == null) break;\n            str += Math.floor(Number(args[a]));\n            lastPos = i = i + 2;\n            break;\n\n          case 79: // 'O'\n\n          case 111: // 'o'\n\n          case 106:\n            {\n              // 'j'\n              if (a >= argLen) {\n                break;\n              }\n\n              if (lastPos < i) {\n                str += f.slice(lastPos, i);\n              }\n\n              if (args[a] === undefined) break;\n\n              var _type = _typeof(args[a]);\n\n              if (_type === 'string') {\n                str += '\\'' + args[a] + '\\'';\n                lastPos = i + 2;\n                i++;\n                break;\n              }\n\n              if (_type === 'function') {\n                str += toFunctionSting(args[a].name);\n                lastPos = i + 2;\n                i++;\n                break;\n              }\n\n              str += ss(args[a]);\n              lastPos = i + 2;\n              i++;\n              break;\n            }\n\n          case 115:\n            // 's'\n            if (a >= argLen) {\n              break;\n            }\n\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n\n            str += String(args[a]);\n            lastPos = i + 2;\n            i++;\n            break;\n\n          case 37:\n            // '%'\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n\n            str += '%';\n            lastPos = i + 2;\n            i++;\n            a--; // stay on same argument\n\n            break;\n        }\n\n        ++a;\n      }\n\n      ++i;\n    }\n\n    if (lastPos === -1) {\n      str = f;\n    } else if (lastPos < flen) {\n      str += f.slice(lastPos);\n    }\n  }\n\n  for (a; a < argLen; a++) {\n    var val = args[a];\n\n    var _type2 = _typeof(val);\n\n    if (_type2 === 'function') {\n      str += ' ' + toFunctionSting(val.name);\n    } else if (_type2 === 'object' && val !== null) {\n      procObj(val);\n    } else {\n      str += ' ' + String(val);\n    }\n  }\n\n  return str;\n}\n\nvar toFunctionSting = function toFunctionSting(name) {\n  return (name || '<anonymous>') + '()';\n};\n\n//# sourceURL=webpack:///../../src/quick-format.js?");

/***/ }),

/***/ "../../src/serializers/err.js":
/*!************************************!*\
  !*** ../../src/serializers/err.js ***!
  \************************************/
/***/ ((module) => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar circ = Symbol('circ');\n\nfunction errSerializer(val) {\n  if (!(val instanceof Error)) {\n    return val;\n  }\n\n  var o = {\n    msg: val.message,\n    name: Object.prototype.toString.call(val.constructor) === '[object Function]' ? val.constructor.name : val.name,\n    stack: val.stack\n  };\n  val[circ] = undefined;\n  Object.entries(val).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        val = _ref2[1];\n\n    if (o[key] === undefined) {\n      if (val instanceof Error) {\n        if (!Object.prototype.hasOwnProperty.call(val, circ)) {\n          o[key] = errSerializer(val);\n        }\n      } else {\n        o[key] = val;\n      }\n    }\n  });\n  return o;\n}\n\nmodule.exports = errSerializer;\n\n//# sourceURL=webpack:///../../src/serializers/err.js?");

/***/ }),

/***/ "../../src/utils.js":
/*!**************************!*\
  !*** ../../src/utils.js ***!
  \**************************/
/***/ ((module) => {

eval("var _NUM_LEVELS;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n */\nvar LOG = 'LOG',\n    TRACE = 'TRACE',\n    DEBUG = 'DEBUG',\n    INFO = 'INFO',\n    WARN = 'WARN',\n    ERROR = 'ERROR',\n    FATAL = 'FATAL',\n    OFF = 'OFF';\nvar LEVELS = {\n  TRACE: [FATAL, ERROR, WARN, INFO, DEBUG, TRACE],\n  DEBUG: [FATAL, ERROR, WARN, INFO, DEBUG],\n  INFO: [FATAL, ERROR, WARN, INFO],\n  WARN: [FATAL, ERROR, WARN],\n  ERROR: [FATAL, ERROR],\n  FATAL: [FATAL],\n  OFF: [OFF]\n};\nvar COLORS = ['#6600FF', '#3333FF', '#3333CC', '#0066FF', '#0066CC', '#0066FF', '#006633', '#006666', '#006600', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#009900', '#009933', '#009966', '#009999', '#00CCFF', '#00CCCC', '#FF9900', '#FF9933', '#FF6600', '#FF6633', '#FF0000', '#FF0033', '#FF3300', '#FF3300', '#FF3333', '#CC0000', '#CC0033', '#CC0066', '#FF0066', '#FF3366', '#FF00FF', '#FF33FF', '#CC00CC', '#990099'];\nvar LEVEL_COLORS = {\n  LOG: '#999999',\n  TRACE: '#00CCFF',\n  DEBUG: '#0066CC',\n  INFO: '#009900',\n  WARN: '#FF9900',\n  ERROR: '#CC0000',\n  FATAL: '#CC00CC'\n};\nvar NUM_LEVELS = (_NUM_LEVELS = {}, _defineProperty(_NUM_LEVELS, TRACE, 10), _defineProperty(_NUM_LEVELS, DEBUG, 20), _defineProperty(_NUM_LEVELS, INFO, 30), _defineProperty(_NUM_LEVELS, LOG, 30), _defineProperty(_NUM_LEVELS, WARN, 40), _defineProperty(_NUM_LEVELS, ERROR, 50), _defineProperty(_NUM_LEVELS, FATAL, 60), _NUM_LEVELS);\n\nvar adjustLevel = function adjustLevel(level, _default) {\n  level = (level || '').toUpperCase();\n  return LEVELS[level] ? level : _default;\n};\n\nvar toNumLevel = function toNumLevel(level) {\n  return NUM_LEVELS[level] || NUM_LEVELS.DEBUG;\n};\n\nvar fromNumLevel = function fromNumLevel(level) {\n  if (typeof level === 'number') {\n    for (var slevel in NUM_LEVELS) {\n      var threshold = NUM_LEVELS[slevel];\n\n      if (level <= threshold) {\n        return slevel;\n      }\n    }\n\n    return FATAL;\n  }\n\n  return level;\n};\n/**\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n */\n\n\nvar inspectOpts = function inspectOpts(obj) {\n  return Object.keys(obj).filter(function (key) {\n    return /^debug_/i.test(key);\n  }).reduce(function (opts, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n      return k.toUpperCase();\n    }); // coerce string value into JS value\n\n    var val = obj[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n\n    if (prop === 'stream' || prop === 'formatters') {// do nothing\n    } else if (prop === 'level') {\n      val = adjustLevel(obj[key]);\n      if (val) opts[prop] = val;\n    } else if (prop === 'url' || prop === 'timestamp') {\n      opts[prop] = obj[key];\n    } else {\n      opts[prop] = val;\n    }\n\n    return opts;\n  }, {});\n};\n\nvar saveOpts = function saveOpts(obj, options) {\n  Object.keys(options).forEach(function (prop) {\n    if (['stream', 'serializers'].includes(prop)) return; // do not safe stream option\n\n    var key = 'DEBUG_' + prop.replace(/([A-Z])/g, function (_, prop) {\n      return '_' + prop.toLowerCase();\n    });\n    if (prop === 'namespaces') key = 'DEBUG';\n    key = key.toUpperCase();\n    obj[key] = options[prop];\n  });\n};\n\nvar selectColor = function selectColor(namespace, fn) {\n  var hash = 0;\n\n  for (var i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  var pos = Math.abs(hash) % COLORS.length;\n  var color = fn(COLORS[pos]);\n  return color;\n};\n\nvar levelColors = function levelColors(fn) {\n  var colors = Object.keys(LEVEL_COLORS).reduce(function (colors, level) {\n    colors[level] = fn(LEVEL_COLORS[level]);\n    return colors;\n  }, {});\n  return colors;\n};\n\nvar inspectNamespaces = function inspectNamespaces(obj) {\n  var namespaces = obj.DEBUG || obj.debug;\n  if (namespaces) return {\n    namespaces: namespaces\n  };\n};\n\nvar random = function random(len) {\n  return Math.random().toString(16).toLowerCase().substr(2, len);\n};\n\nmodule.exports = {\n  LOG: LOG,\n  TRACE: TRACE,\n  DEBUG: DEBUG,\n  INFO: INFO,\n  WARN: WARN,\n  ERROR: ERROR,\n  FATAL: FATAL,\n  OFF: OFF,\n  LEVELS: LEVELS,\n  COLORS: COLORS,\n  LEVEL_COLORS: LEVEL_COLORS,\n  adjustLevel: adjustLevel,\n  toNumLevel: toNumLevel,\n  fromNumLevel: fromNumLevel,\n  inspectOpts: inspectOpts,\n  saveOpts: saveOpts,\n  inspectNamespaces: inspectNamespaces,\n  selectColor: selectColor,\n  levelColors: levelColors,\n  random: random\n};\n\n//# sourceURL=webpack:///../../src/utils.js?");

/***/ }),

/***/ "../../src/wrapConsole.js":
/*!********************************!*\
  !*** ../../src/wrapConsole.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var _require = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\"),\n    adjustLevel = _require.adjustLevel,\n    LOG = _require.LOG,\n    TRACE = _require.TRACE,\n    DEBUG = _require.DEBUG,\n    INFO = _require.INFO,\n    WARN = _require.WARN,\n    ERROR = _require.ERROR;\n\nvar LEVELS = [LOG, TRACE, DEBUG, INFO, WARN, ERROR];\nvar wrapped = null;\n\nvar unwrap = function unwrap() {\n  if (wrapped) {\n    LEVELS.forEach(function (level) {\n      console[level] = wrapped[level];\n    });\n    wrapped = null;\n  }\n};\n/**\n * wrap console logging functions like\n * console.log, console.info, console.warn, console.error\n * @return {function} unwrap function\n */\n\n\nfunction wrapConsole(log) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$level4log = _ref.level4log,\n      level4log = _ref$level4log === void 0 ? 'LOG' : _ref$level4log;\n\n  if (wrapped) return unwrap;\n  wrapped = {};\n\n  var _level4log = adjustLevel(level4log, 'LOG').toLowerCase();\n\n  var render = function render(level) {\n    return function () {\n      log[level].apply(log, arguments);\n    };\n  };\n\n  LEVELS.map(function (l) {\n    return l.toLowerCase();\n  }).forEach(function (level) {\n    wrapped[level] = console[level];\n    var renderLevel = level === 'log' ? _level4log : level;\n    console[level] = render(renderLevel);\n  });\n  return unwrap;\n}\n\nmodule.exports = wrapConsole;\n\n//# sourceURL=webpack:///../../src/wrapConsole.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;