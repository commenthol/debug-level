/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/.pnpm/asyncc@2.0.6/node_modules/asyncc/dist/index.es.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/asyncc@2.0.6/node_modules/asyncc/dist/index.es.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsynccError\": () => (/* binding */ AsynccError),\n/* harmony export */   \"NoPromise\": () => (/* binding */ NoPromise),\n/* harmony export */   \"Queue\": () => (/* binding */ Queue),\n/* harmony export */   \"_setImmediate\": () => (/* binding */ _setImmediate),\n/* harmony export */   \"compose\": () => (/* binding */ compose),\n/* harmony export */   \"connect\": () => (/* binding */ connect),\n/* harmony export */   \"default\": () => (/* binding */ index),\n/* harmony export */   \"doUntil\": () => (/* binding */ doUntil),\n/* harmony export */   \"doWhilst\": () => (/* binding */ doWhilst),\n/* harmony export */   \"each\": () => (/* binding */ each),\n/* harmony export */   \"eachLimit\": () => (/* binding */ eachLimit),\n/* harmony export */   \"eachSeries\": () => (/* binding */ eachSeries),\n/* harmony export */   \"noPromise\": () => (/* binding */ noPromise),\n/* harmony export */   \"parallel\": () => (/* binding */ parallel),\n/* harmony export */   \"parallelLimit\": () => (/* binding */ parallelLimit),\n/* harmony export */   \"queue\": () => (/* binding */ queue),\n/* harmony export */   \"retry\": () => (/* binding */ retry),\n/* harmony export */   \"series\": () => (/* binding */ series),\n/* harmony export */   \"times\": () => (/* binding */ times),\n/* harmony export */   \"until\": () => (/* binding */ until),\n/* harmony export */   \"whilst\": () => (/* binding */ whilst)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\n* setImmediate wrapper for different environments\n* @method _setImmediate\n* @static\n*/\nvar _setImmediate = function () {\n  /* istanbul ignore next */\n  if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && typeof process.nextTick === 'function') {\n    // nodejs\n    return process.nextTick;\n  } else if (typeof setImmediate === 'function') {\n    // supporting browsers\n    return setImmediate;\n  } else {\n    // fallback\n    return function (fn) {\n      setTimeout(fn, 0);\n    };\n  }\n}();\nvar AsynccError = /*@__PURE__*/function (Error) {\n  function AsynccError(message, errors, errpos) {\n    Error.call(this, message);\n    Object.assign(this, {\n      name: 'AsynccError',\n      message: message,\n      errors: errors,\n      errpos: errpos,\n      stack: this.stack || /* istanbul ignore next */new Error().stack\n    });\n  }\n  if (Error) AsynccError.__proto__ = Error;\n  AsynccError.prototype = Object.create(Error && Error.prototype);\n  AsynccError.prototype.constructor = AsynccError;\n  return AsynccError;\n}(Error);\n\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a task are passed no the next task.\n * Stops on errors and immediatelly calls optional `callback` in this case.\n *\n * @name compose\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type\n * `function (arg: any, cb: function)`\n * `arg` - an argument which is passed from one task to the other\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg: any, cb: function)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback `function(err: <Error>, res: any)`\n * @example\n * var c = compose(\n *   (res, cb) => { cb(null, res + 1) },\n *   (res, cb) => { cb('error', res * 2) }, // breaks here on first error\n *   (res, cb) => { cb(null, res + 3) },\n * )\n * c(2, function (err, res) {\n *   //> err = 'error'\n *   //> res = 6\n * })\n */\nfunction compose() {\n  var tasks = [],\n    len = arguments.length;\n  while (len--) tasks[len] = arguments[len];\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n  return function (arg, callback) {\n    var i = 0;\n    function run(err, res) {\n      var fn = tasks[i++];\n      if (err || !fn) {\n        callback && callback(err, res);\n      } else {\n        fn(res, run);\n      }\n    }\n    run(null, arg);\n  };\n}\n\n/**\n * Run composed `tasks` callback functions in series.\n * Results from a **task** are passed to the next task.\n * Passed or thrown errors in tasks get trapped with\n * functions of arity 3 `function (err, res, cb)` called here **trap**.\n * In case that there is no previous error, a **trap** acts as \"no-op\".\n * In case that no **trap** is defined then the chain exits to an optional `callback`.\n *\n * @name connect\n * @memberOf module:serial\n * @static\n * @method\n * @param {...Function|Array} tasks - Arguments or Array of callback functions of type **task**\n * `function (arg: any, cb: function)` or **trap** `function (err: <Error>, arg: any, cb: function)` where\n * `arg` - an argument which is passed from one task to the other\n * `err` - a trapped error from previous tasks\n * `cb` - the callback function which needs to be called on completion\n * @return {Function} composed function of `function (arg, cb)` where\n * `arg` - initial argument which is passed from one task to the other\n * `[callback]` - optional callback function `function(err: <Error>, res: any)`\n * @example\n * var c = connect(\n *   (res, cb) => { cb(null, res + 1) },      // task\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - \"no-op\" here as there is no previous error\n *   (res, cb) => { cb(null, res * 2) }       // task\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 6\n * })\n *\n * @example <caption>With error traps</caption>\n * var c = connect(\n *   (res, cb) => { cb('error', res + 1) },   // task - error is passed to next task\n *   (res, cb) => { cb(null, res * 2) },      // task - \"no-op\", jumps over this task due to previous error\n *   (err, res, cb) => { cb(null, res + 3) }, // trap - error gets trapped here (arity === 3)\n *   (res, cb) => { cb(null, res * 2) }       // task - continues\n * )\n * c(2, function (err, res) {\n *   //> err = null\n *   //> res = 12\n * })\n *\n */\nfunction connect() {\n  var tasks = [],\n    len = arguments.length;\n  while (len--) tasks[len] = arguments[len];\n  if (tasks.length === 1 && Array.isArray(tasks[0])) {\n    tasks = tasks[0];\n  }\n  return function (arg, callback) {\n    var i = 0;\n    run(null, arg);\n    function run(err, res) {\n      var fn = tasks[i++];\n      try {\n        if (err) {\n          // search for next function of arity 3\n          while (fn && fn.length !== 3) {\n            fn = tasks[i++];\n          }\n          fn && fn(err, res, run);\n        } else {\n          // jump over all error traps\n          while (fn && fn.length > 2) {\n            fn = tasks[i++];\n          }\n          fn && fn(res, run); // step\n        }\n      } catch (e) {\n        run(e, res);\n      }\n      if (!fn) {\n        callback && callback(err, res);\n      }\n    }\n  };\n}\n\n/**\n* Run `task` one or more times until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name doUntil\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doUntil(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index >= 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\nfunction doUntil(task, test, callback) {\n  var i = 0;\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n  function run() {\n    task(cb, i++);\n  }\n  run();\n}\n\n/**\n* Run `task` one or more times until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name doWhilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n* @example\n* let arr = []\n* doWhilst(\n*   (cb, index) => {    // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (index) => {     // test\n*     return index < 4\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\nfunction doWhilst(task, test, callback) {\n  doUntil(task, function (n) {\n    return !test(n);\n  }, callback);\n}\nfunction parallel$1(limit, length, run, opts, callback) {\n  if (opts === void 0) opts = {};\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  limit = Math.abs(limit || length);\n  var errpos = [];\n  var errors = new Array(length).fill();\n  var results = new Array(length).fill();\n  var i = 0;\n  var l = length;\n  var done = 0;\n  if (l === 0) {\n    _final();\n    return;\n  }\n  if (opts.timeout) {\n    setTimeout(function () {\n      /* istanbul ignore else */\n      if (l) {\n        _final('err_timeout');\n      }\n    }, opts.timeout);\n  }\n  limit = limit < length ? limit : length;\n  while (i < limit) {\n    run(i++, cb);\n  }\n  function _final(errMsg) {\n    if (done++) {\n      return;\n    }\n    var err = null;\n    if (errpos.length || errMsg) {\n      err = new AsynccError(errMsg || 'err', errors, errpos);\n    }\n    callback && callback(err, results);\n  }\n  function cb(j, err, res) {\n    results[j] = res;\n    errors[j] = err;\n    if (err) {\n      errpos.push(j);\n      if (opts.bail) {\n        _final('err_bail');\n        return;\n      }\n    }\n    l--;\n    if (i < length) {\n      run(i++, cb);\n    } else if (!l) {\n      _final();\n    }\n  }\n}\n\n/**\n* Run `items` on async `task` function in parallel limited to `limit` parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name eachLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* eachLimit(2, [1, 2, 3, 4],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null, 'error']\n*     //> err.errpos = [1, 3]\n*     //> res = [1, 4, 5, 7]\n*   }\n* )\n*/\nfunction eachLimit(limit, items, task, opts, callback) {\n  function run(j, cb) {\n    task(items[j], function (err, res) {\n      cb(j, err, res);\n    }, j);\n  }\n  parallel$1(limit, items.length, run, opts, callback);\n}\n\n/**\n* Run `items` on async `task` function in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n*\n* @name each\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Array} items - Array of items `any[]`\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* each([1, 2, 3],\n*   (item, cb, index) => {\n*     cb(index % 2 ? null : 'error', item + index)\n*   }, (err, res) => {\n*     //> err.errors = [null, 'error', null]\n*     //> err.errpos = [1]\n*     //> res = [1, 4, 5]\n*   }\n* )\n*/\nfunction each(items, task, opts, callback) {\n  eachLimit(0, items, task, opts, callback);\n}\n\n/**\n * Run `items` on async `task` function in series. Stops at the first error encountered.\n *\n * @name eachSeries\n * @memberOf module:serial\n * @static\n * @method\n * @param {Array<any>} items - Array of items\n * @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n * @param {Function} [callback] - optional callback `function (errors: <Error>, result: Array<any>)`\n * @example\n * eachSeries([1, 2, 3],\n *   (item, cb, index) => {\n *     setImmediate(() => {\n *       cb(index % 2 ? null : 'error', item + index)\n *     })\n *   }, (err, res) => {\n *     //> err = 'error'\n *     //> res = [1, 4]\n *   }\n * )\n */\nfunction eachSeries(items, task, callback) {\n  var length = items.length;\n  var results = [];\n  var i = 0;\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n  run();\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else  */\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n  function run() {\n    task(items[i], cb, i++);\n  }\n}\n\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* This method is similar to {@link module:serial.connect|connect} but allows adding `tasks` on the go through chaining.\n*\n* @name NoPromise\n* @class\n* @param {Any} arg - initial argument which is passed to first chain\n* @example <caption>Normal usage</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb(null, res)\n* }).end((err, res) => {\n*   //> err = null\n*   //> res = [1, 2]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Catch errors</caption>\n* var arr = []\n* var n = new NoPromise(arr)\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(2)\n*   cb('err1', res)             // <-- cause an error\n* }).catch((err, res, cb) => {  // catches err1\n*   res.push(err)\n*   cb(null, res)               // <-- continue normally\n* }).then((res, cb) => {\n*   res.push(3)\n*   cb(null, res)\n* }).catch((err, res, cb) => {  // jumps over, as there is no error in the chain\n*   res.push(4)\n*   cb(null, res)\n* }).then((res, cb) => {\n*   res.push(5)\n*   cb('err2', res)             // <-- next error\n* }).end((err, res) => {\n*   //> err = 'err2'\n*   //> res = [1, 2, 'err1', 3, 5]\n*   //> (arr ==== res) = true\n* })\n* @example <caption>Deferred usage</caption>\n* var arr = []\n* // creates a new instance passing `arr`\n* var n = new NoPromise(arr)\n* // execute the first async method\n* n.then((res, cb) => {\n*   res.push(1)\n*   cb(null, res)\n* })\n* // take a time off\n* setTimeout(() => {\n*   // continue processing\n*   n.then((res, cb) => {\n*     res.push(2)\n*     cb(null, res)\n*   }).end((err, res) => {\n*     //> err = null\n*     //> res = [1, 2]\n*     //> (arr ==== res) = true\n*   })\n* }, 10)\n*/\nfunction NoPromise(arg) {\n  this._tasks = [];\n  this.result = arg;\n  this.error = undefined;\n  this._lock = false;\n}\nNoPromise.prototype = {\n  /**\n   * runs the next function\n   * @private\n   */\n  _run: function _run() {\n    var this$1$1 = this;\n    if (this._lock) {\n      return;\n    }\n    this._lock = true;\n    var task = this._tasks.shift();\n    var tstType = this.error ? ['catch', 'end'] : ['then', 'end'];\n    while (task && !~tstType.indexOf(task.type)) {\n      task = this._tasks.shift();\n    }\n    if (task) {\n      var cb = function cb(err, res) {\n        this$1$1.error = err;\n        this$1$1.result = res || this$1$1.result;\n        this$1$1._lock = false;\n        this$1$1._run();\n      };\n      var fn = task.fn;\n      if (task.type === 'end') {\n        // .end\n        fn(this.error, this.result);\n      } else {\n        try {\n          if (task.type === 'catch') {\n            // .catch\n            fn(this.error, this.result, cb);\n          } else {\n            // .then\n            fn(this.result, cb);\n          }\n        } catch (e) {\n          cb(e);\n        }\n      }\n    } else {\n      this._lock = false;\n    }\n  },\n  /**\n   * Chain the next async function\n   * @param {Function} task - async function `function (res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  then: function then(task) {\n    this._tasks.push({\n      type: 'then',\n      fn: task\n    });\n    this._run();\n    return this;\n  },\n  /**\n   * Catch any previous errors from the chain\n   * @param {Function} trap - async function `function (err: <Error>, res: any, cb: Function)`.\n   * Never forget to call `cb(err: <Error>, res: any)` inside `fn`\n   */\n  \"catch\": function _catch(trap) {\n    this._tasks.push({\n      type: 'catch',\n      fn: trap\n    });\n    this._run();\n    return this;\n  },\n  /**\n   * End the chain\n   * @param {Function} callback - `function (err: <Error>, res: any)`\n   */\n  end: function end(callback) {\n    this._tasks.push({\n      type: 'end',\n      fn: callback\n    });\n    this._run();\n  }\n};\n\n/**\n* This is not a `Promise`.\n*\n* Chain callback functions with `.then(function (res, cb))` and execute them\n* as soon as previous callbacks have finished.\n*\n* Catch passed or thrown errors with `.catch(function (err, res, cb))` as they may occur.\n* End the chain with `.end(function (err, res))`.\n*\n* If errors are thrown inside a `task` they are catched and can be processed attaching\n* `.catch()` or `.end()` to the chain.\n*\n* See full API here {@link NoPromise}.\n*\n* @name noPromise\n* @memberOf module:serial\n* @static\n* @method\n* @param {Any} arg - initial argument which is passed to first chain\n* @return {NoPromise}\n*/\nfunction noPromise(arg) {\n  return new NoPromise(arg);\n}\n\n/**\n* Run `tasks` callback functions in parallel limited to `limit` parallel\n* running tasks.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallelLimit\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Number} limit - number of tasks running in parallel\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n*\n* @example\n* // runs 2 tasks in parallel\n* parallelLimit(2, [\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errorpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\nfunction parallelLimit(limit, tasks, opts, callback) {\n  function run(j, cb) {\n    tasks[j](function (err, res) {\n      cb(j, err, res);\n    });\n  }\n  parallel$1(limit, tasks.length, run, opts, callback);\n}\n\n/**\n* Run `tasks` callback functions in parallel.\n*\n* Does not stop parallel execution on errors. *All tasks get executed.*\n* The optional `callback` gets called after the longest running task finishes.\n*\n* @name parallel\n* @memberOf module:parallel\n* @static\n* @method\n\n* @param {Array<Function>} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Object} [options]\n* @param {Number} [options.timeout] - timeout in ms which throwing `AsynccError` in case that `tasks` are still running\n* @param {Boolean} [options.bail] - bail-out on first error\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: AsynccError, result: Array<any>)`\n* where `err.errors` is an Array containing the errors in the same\n* order as the `res` results array. `err.errpos` gives the positions of errors in\n* order as they occur.\n* @example\n* parallel([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) },\n*   (cb) => { cb(null, 3) }\n* ], (err, res) => {\n*   //> err.errors = [null, 'error', null]\n*   //> err.errpos = [1]\n*   //> res = [1, 2, 3]\n* })\n*/\nfunction parallel(tasks, opts, callback) {\n  parallelLimit(0, tasks, opts, callback);\n}\n\n/**\n* Creates an Array which adds items by priority\n*/\nfunction PrioArray() {\n  this.reset();\n}\nPrioArray.prototype = {\n  /**\n  * length of Array\n  */\n  get length() {\n    return this.items.length;\n  },\n  /**\n  * shift item from array\n  * @return {Any} item\n  */\n  shift: function shift() {\n    return (this.items.shift() || /* istanbul ignore next */{}).item;\n  },\n  /**\n  * push `item` to Array using priority\n  * @param {Any} item\n  * @param {Number} [prio=Infinity] - priority `0 ... Infinity` - lower values have higher priority\n  */\n  push: function push(item, prio) {\n    var items = this.items;\n    if (typeof prio !== 'number') {\n      prio = Infinity;\n      items.push({\n        prio: prio,\n        item: item\n      });\n    } else {\n      var found;\n      prio = Math.abs(prio);\n      for (var i = 0; i < items.length; i++) {\n        if (prio < items[i].prio) {\n          items.splice(i, 0, {\n            prio: prio,\n            item: item\n          });\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        items.push({\n          prio: prio,\n          item: item\n        });\n      }\n    }\n    return this;\n  },\n  /**\n  * unshift `item` to Array using priority\n  * @param {Any} item\n  */\n  unshift: function unshift(item) {\n    this.items.unshift({\n      prio: 0,\n      item: item\n    });\n    return this;\n  },\n  /**\n  * removes all items in the Array\n  */\n  reset: function reset() {\n    this.items = [];\n  }\n};\n\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* @name Queue\n* @methodOf: module:parallel\n* @class\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @example <caption>Default usage</caption>\n* var arr = []\n* var q = new Queue((item, cb) => {\n*   arr.push(item)\n*   cb(null, item)\n* })\n* // push item \"one\" at end of queue\n* q.push('one', (err, res) => {\n*   console.log(res + ' finished')\n* })\n* // add item \"two\" at start of queue\n* q.unshift('two', () => {\n*   console.log('two finished')\n* })\n* // called when all items in queue where processed\n* q.drain(() => {\n*   console.log(arr)\n*   //> arr = ['one', 'two']\n* })\n* @example <caption>Using priorities</caption>\n* let arr = []\n*\n* let q = new Queue(function (item, cb) {\n*   arr.push(item)\n*   cb()\n* }, 2)\n*\n* q.concat([100, 101, 102], 3) // priority = 3 - last (but 2 items already processed)\n* q.concat([0, 1, 2], 1)       // priority = 1 - first\n* q.concat([10, 11, 12], 2)    // priority = 2 - second\n*\n* q.drain(() => {\n*   //> arr = [ 100, 101, 0, 1, 2, 10, 11, 12, 102 ])\n* })\n*/\nfunction Queue(task, concurrency) {\n  this._task = task;\n  this._concurrency = Math.abs(concurrency || 1);\n  this._worker = 0;\n  this._paused = false;\n  this._items = new PrioArray();\n}\nQueue.prototype = {\n  /**\n  * process items in queue\n  * @private\n  */\n  _run: function _run() {\n    var this$1$1 = this;\n    var ref = this;\n    var _items = ref._items;\n    var _drain = ref._drain;\n    this._worker -= 1;\n    if (_items.length === 0) {\n      if (this._worker <= 0) {\n        this._worker = 0;\n        _drain && _drain();\n      }\n    } else {\n      this._worker += 1;\n      var ref$1 = _items.shift();\n      var item = ref$1[0];\n      var cb = ref$1[1];\n      this._task(item, function (err, res) {\n        cb && cb(err, res);\n        _setImmediate(function () {\n          // prevent RangeError: Maximum call stack size exceeded for sync tasks\n          this$1$1._run();\n        });\n      });\n    }\n  },\n  /**\n  * start processing queue or add workers up to concurrency\n  * @private\n  */\n  _start: function _start() {\n    while (!this._paused && this._worker < Math.min(this._concurrency, this._items.length)) {\n      this._worker += 1;\n      this._run();\n    }\n    return this;\n  },\n  /**\n  * Check if queue is paused\n  * @return {Boolean} `true` if paused\n  */\n  get paused() {\n    return this._paused;\n  },\n  /**\n  * Check if queue is idle - means no items in queue and no workers running\n  * @return {Boolean} `true` if idle\n  */\n  get idle() {\n    return !this.length && this._worker === 0;\n  },\n  /**\n  * Number of items waiting in the queue to get processed\n  * @return {Number} number of items in queue\n  */\n  get length() {\n    return this._items.length;\n  },\n  /**\n  * Pause processing\n  * @return {this} for chaining\n  */\n  pause: function pause() {\n    this._paused = true;\n    return this;\n  },\n  /**\n  * Resume processing\n  * @return {this} for chaining\n  */\n  resume: function resume() {\n    this._paused = false;\n    return this._start();\n  },\n  /**\n  * Reset the queue by removing all pending items from the queue\n  * @return {this} for chaining\n  */\n  reset: function reset() {\n    this._items.reset();\n    return this;\n  },\n  /**\n  * Number of items being processed\n  * @return {Number} number of items processed\n  */\n  running: function running() {\n    return this._worker;\n  },\n  /**\n  * push `item` onto queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  push: function push(item, callback, priority) {\n    return this.concat([item], callback, priority);\n  },\n  /**\n  * concat `items` onto queue - fills the queue first with `items` before starting processing\n  * @param {Any[]} items\n  * @param {Function} [callback] - optional callback if single item was processed\n  * @param {Number} [priority] - priority `0 ... Infinity` of the item to process. Smaller values, faster processing\n  * @return {this} for chaining\n  */\n  concat: function concat(items, callback, priority) {\n    var this$1$1 = this;\n    if (typeof callback === 'number') {\n      priority = callback;\n      callback = undefined;\n    }\n    items.forEach(function (item) {\n      this$1$1._items.push([item, callback], priority);\n    });\n    return this._start();\n  },\n  /**\n  * put `item` at the very beginnning of the queue\n  * @param {Any} item\n  * @param {Function} [callback] - optional callback if item was processed\n  * @return {this} for chaining\n  */\n  unshift: function unshift(item, callback) {\n    this._items.unshift([item, callback]);\n    return this._start();\n  },\n  /**\n  * @param {Function} [callback] - optional callback called if all queue items got processed\n  * @return {this} for chaining\n  */\n  drain: function drain(callback) {\n    this._drain = callback;\n    return this;\n  }\n};\n\n/**\n* Run queued `items` through an asynchronous `task`.\n*\n* Once finishing the `task` an optional callback is called.\n* While pushing to the queue, you may define a priority for execution.\n* Lower values means faster execution.\n*\n* See full API here {@link Queue}.\n*\n* @name queue\n* @memberOf module:parallel\n* @static\n* @method\n* @param {Function} task - iterator function of type `function (item: any, cb: Function, index: Number)`\n* @param {Number} concurrency - max. number of tasks running in parallel\n* @return {Queue}\n*/\nfunction queue(task, concurrency) {\n  return new Queue(task, concurrency);\n}\n\n/**\n* @private\n*/\nfunction _times(num, opts) {\n  opts = opts || {};\n  var fn = _setImmediate;\n  var lag = 0;\n  var times = num;\n  if (typeof num !== 'number') {\n    times = num.times;\n    lag = num.lag || 0;\n  }\n  times = times || opts.times || 0;\n  if (lag) {\n    fn = setTimeout;\n  }\n  return {\n    times: times,\n    lag: lag,\n    fn: fn\n  };\n}\n\n/**\n* Run `task` max. `times` times. Stops at first iteration where no error is returned.\n*\n* Calls `callback` if `times` is reached or `task` returned no error.\n*\n* @name retry\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - retry max. `times` times - default=2\n* @param {Number} [times.times=2] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n* @example\n* let arr = []\n* retry({times: 3, lag: 100}, // max. 3 retries with 100ms time-lag between retries\n*   (cb, index) => { // task\n*     let err = index < 2 ? new Error() : null\n*     arr.push(index)\n*     cb(err, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 2\n*     //> arr = [0, 1, 2]\n*   }\n* )\n*/\nfunction retry(num, task, callback) {\n  var i = 0;\n  var ref = _times(num, {\n    times: 2\n  });\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n  run();\n  function cb(err, res) {\n    if (!err || i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n  function run() {\n    task(cb, i++);\n  }\n}\n\n/**\n* Run `tasks` callback functions in series\n* The function breaks after the first error encountered and calls optional\n* `callback` function\n*\n* @name series\n* @memberOf module:serial\n* @static\n* @method\n* @param {Array} tasks - Array of callback functions of type `function (cb: Function)`\n* @param {Function} [callback] - optional callback function called by last\n* terminating function from `tasks`, needs to be of type\n* `function (err: Error, res: Array<any>)`\n*\n* @example\n* series([\n*   (cb) => { cb(null, 1) },\n*   (cb) => { cb('error', 2) }, // breaks on first error\n*   (cb) => { cb(null, 3) },\n* ], (err, res) => {\n*   //> err = 'error'\n*   //> res = [1, 2]\n* })\n*/\nfunction series(tasks, callback) {\n  var length = tasks.length;\n  var results = [];\n  var i = 0;\n  if (length === 0) {\n    callback(null, []);\n    return;\n  }\n  run();\n  function run() {\n    tasks[i++](cb);\n  }\n  function cb(err, res) {\n    results.push(res);\n    /* istanbul ignore else */\n    if (err || length === i) {\n      callback && callback(err, results);\n    } else if (i < length) {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n}\n\n/**\n* Run `task` repeatedly until number `times` is reached.\n*\n* Stops at the first error encountered.\n* An optional `lag` between retries may be used.\n*\n* @name times\n* @memberOf module:serial\n* @static\n* @method\n* @param {Number|Object} times - runs `times` times. If `times < 0` then \"times\" cycles endlessly until an error occurs.\n* @param {Number} [times.times=0] - max. number of retries\n* @param {Number} [times.lag=0] - time-lag in ms between retries\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: Array<any>)`\n*\n* @example\n* let arr = []\n* times({times: 4, lag: 100}, // 4 times with 100ms time-lag between retries\n*   (cb, index) => {\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\nfunction times(num, task, callback) {\n  var i = 0;\n  var ref = _times(num);\n  var times = ref.times;\n  var lag = ref.lag;\n  var fn = ref.fn;\n  if (times) {\n    run();\n  } else {\n    callback && callback();\n  }\n  function cb(err, res) {\n    if (err || times > 0 && i >= times) {\n      callback && callback(err, res);\n    } else {\n      fn(function () {\n        run();\n      }, lag);\n    }\n  }\n  function run() {\n    task(cb, i++);\n  }\n}\n\n/**\n* Run `task` repeatedly until `test` returns `true`.\n* Calls `callback` at the first error encountered.\n*\n* @name until\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `true` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: <Error>, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* until(\n*   (index) => {        // test\n*     return index >= 4\n*   }, (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => {  // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\nfunction until(test, task, callback) {\n  var i = 0;\n  function cb(err, res) {\n    if (err || test(i)) {\n      callback && callback(err, res);\n    } else {\n      _setImmediate(function () {\n        // prevent RangeError: Maximum call stack size exceeded for sync tasks\n        run();\n      });\n    }\n  }\n  function run() {\n    task(cb, i++);\n  }\n  if (!test(i)) {\n    run();\n  } else {\n    callback && callback();\n  }\n}\n\n/**\n* Run `task` repeatedly until `test` returns `false`.\n* Calls `callback` at the first error encountered.\n*\n* @name whilst\n* @memberOf module:serial\n* @static\n* @method\n* @param {Function} test - test function `function (index: number)`. If return value is `false` then `callback` gets called\n* @param {Function} task - iterator function of type `function (cb: Function, index: Number)`\n* @param {Function} [callback] - optional callback `function (errors: Error, result: any)` from last callback.\n*\n* @example\n* let arr = []\n* whilst(\n*   (index) => (index < 4), // test\n*   (cb, index) => { // task\n*     arr.push(index)\n*     cb(null, index)\n*   }, (err, res) => { // callback\n*     //> err = null\n*     //> res = 3\n*     //> arr = [0, 1, 2, 3]\n*   }\n* )\n*/\nfunction whilst(test, task, callback) {\n  until(function (n) {\n    return !test(n);\n  }, task, callback);\n}\n\n/**\n* Serial execution patterns\n* @module serial\n*/\n\nvar index = {\n  _setImmediate: _setImmediate,\n  AsynccError: AsynccError,\n  compose: compose,\n  connect: connect,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  each: each,\n  eachLimit: eachLimit,\n  eachSeries: eachSeries,\n  noPromise: noPromise,\n  NoPromise: NoPromise,\n  parallel: parallel,\n  parallelLimit: parallelLimit,\n  queue: queue,\n  Queue: Queue,\n  retry: retry,\n  series: series,\n  times: times,\n  until: until,\n  whilst: whilst\n};\n\n\n//# sourceURL=webpack:///../../node_modules/.pnpm/asyncc@2.0.6/node_modules/asyncc/dist/index.es.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nmodule.exports = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = '[...]';\nvar CIRCULAR_REPLACE_NODE = '[Circular]';\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  };\n}\n\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  decirc(obj, '', 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, {\n        value: replace\n      });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions();\n  }\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (_typeof(val) === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n    if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer = typeof replacer !== 'undefined' ? replacer : function (k, v) {\n    return v;\n  };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n\n//# sourceURL=webpack:///../../node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = _typeof(val);\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/browser.js */ \"../../src/browser.js\");\n\nwindow.localStorage.setItem('DEBUG_URL', '/debug-level');\nwindow.localStorage.setItem('DEBUG', '*');\nvar log = new _src_browser_js__WEBPACK_IMPORTED_MODULE_0__.Log('myApp');\nvar ORD = ['th', 'st', 'nd', 'rd'];\nvar ordinals = function ordinals(num) {\n  return num + (num > 10 && num < 14 ? 'th' : ORD[num % 10] || ORD[0]);\n};\nvar LEVEL = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];\nvar levels = function levels() {\n  return LEVEL[Math.random() * LEVEL.length | 0];\n};\nvar count = 1;\nsetInterval(function () {\n  var level = levels().toLowerCase();\n  log[level]('my %s logline at %s', ordinals(count++), new Date().toString());\n}, 500);\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "../../src/Format.js":
/*!***************************!*\
  !*** ../../src/Format.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Format\": () => (/* binding */ Format)\n/* harmony export */ });\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-safe-stringify */ \"../../node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var _quick_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quick-format.js */ \"../../src/quick-format.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n/**\n * @typedef {object} FormatOption\n * @property {number} [spaces] number of spaces to use for formatting\n */\n\nvar Format = /*#__PURE__*/function () {\n  /**\n   * @param {FormatOption} opts\n   */\n  function Format() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Format);\n    this.opts = {\n      opts: opts\n    };\n    this._formatOpts();\n  }\n  _createClass(Format, [{\n    key: \"spaces\",\n    get: function get() {\n      return this.opts.spaces;\n    },\n    set: function set(spaces) {\n      this.opts.spaces = spaces;\n      this._formatOpts();\n    }\n  }, {\n    key: \"_formatOpts\",\n    value: function _formatOpts() {\n      var _this = this;\n      // @ts-expect-error\n      this.formatOpts = {\n        stringify: function stringify(o) {\n          return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__(o, null, _this.opts.spaces);\n        }\n      };\n    }\n  }, {\n    key: \"stringify\",\n    value: function stringify() {\n      // @ts-expect-error\n      return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_0__.apply(void 0, arguments);\n    }\n\n    /**\n     * formats arguments like `util.format`\n     * @param {any} fmt may contain \"%\" formatters\n     * @param {any} args arguments list\n     * @param {any} obj\n     * @return {Array} first is formatted message, other args may follow\n     */\n  }, {\n    key: \"format\",\n    value: function format(fmt, args, obj) {\n      return (0,_quick_format_js__WEBPACK_IMPORTED_MODULE_1__.format)(fmt, args, this.formatOpts, obj);\n    }\n  }]);\n  return Format;\n}();\n\n//# sourceURL=webpack:///../../src/Format.js?");

/***/ }),

/***/ "../../src/LogBase.js":
/*!****************************!*\
  !*** ../../src/LogBase.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogBase\": () => (/* binding */ LogBase)\n/* harmony export */ });\n/* harmony import */ var _Format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Format.js */ \"../../src/Format.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\");\n/* harmony import */ var _Namespaces_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Namespaces.js */ \"../../src/Namespaces.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\nvar noop = function noop() {};\n\n/** @typedef {'epoch'|'unix'|'iso'} Timestamp */\n\nvar time = {\n  epoch: function epoch() {\n    return Date.now();\n  },\n  unix: function unix() {\n    return Date.now() / 1000 | 0;\n  },\n  iso: function iso() {\n    return new Date().toISOString();\n  }\n};\n\n/**\n * @typedef {import('./utils').Level} Level\n *\n * @typedef {object} ExtLogBaseOptions\n * @property {Level} [level] log level\n * @property {string} [namespaces] namespaces for logging\n * @property {boolean} [levelNumbers] use number instead of log level name\n * @property {boolean} [json] log as nd-json\n * @property {boolean} [colors] log with colors\n * @property {Timestamp} [timestamp] log with timestamp; if undefined then no timestamp is logged\n * @property {number} [spaces] number of spaces for pretty print JSON\n * @property {boolean} [splitLine] split lines for pretty \"debug\" like output (not recommended for prod use)\n * @property {object} [serializers] serializers to be applied on object properties\n *\n * @typedef {import('./Format.js').FormatOption} FormatOption\n * @typedef {FormatOption & ExtLogBaseOptions} LogBaseOptions\n */\n\nvar LogBase = /*#__PURE__*/function () {\n  /**\n   * @param {string} name\n   * @param {LogBaseOptions} opts\n   */\n  function LogBase(name) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, LogBase);\n    this.name = name;\n    this.opts = opts;\n    this._enabled = {};\n    this.formatter = new _Format_js__WEBPACK_IMPORTED_MODULE_0__.Format(opts);\n\n    /** @type {{ [x: string]: (arg0: any) => any; } | null} */\n    this.serializers = Object.entries(this.opts.serializers || {}).reduce(function ( /** @type {object} */curr, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        val = _ref2[1];\n      if (typeof val === 'function') {\n        curr = curr || {};\n        curr[key] = val;\n      }\n      return curr;\n    }, null);\n    this._timeF = time[opts.timestamp];\n    this._time = this._timeF ? this._timeF : noop;\n\n    // log level function for TS\n    /** always logs */\n    this.log = noop;\n    /** log with level FATAL */\n    this.fatal = noop;\n    /** log with level ERROR */\n    this.error = noop;\n    /** log with level WARN */\n    this.warn = noop;\n    /** log with level INFO */\n    this.info = noop;\n    /** log with level DEBUG */\n    this.debug = noop;\n    /** log with level TRACE */\n    this.trace = noop;\n\n    // other definitions for TS\n    /** @type {number|undefined} */\n    this.pid = undefined;\n    /** @type {string|undefined} */\n    this.hostname = undefined;\n    this.enable();\n  }\n\n  /**\n   * @param {string} [namespaces]\n   */\n  _createClass(LogBase, [{\n    key: \"enable\",\n    value: function enable() {\n      var _this = this;\n      var namespaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.opts.namespaces;\n      var namespace = new _Namespaces_js__WEBPACK_IMPORTED_MODULE_2__.Namespaces(namespaces);\n      this._enabled = {}; // reset\n      var level = namespace.isEnabled(this.name, this.opts.level);\n      var active = level ? _utils_js__WEBPACK_IMPORTED_MODULE_1__.LEVELS[(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.adjustLevel)(level, _utils_js__WEBPACK_IMPORTED_MODULE_1__.INFO)] : [];\n      _utils_js__WEBPACK_IMPORTED_MODULE_1__.LEVELS.TRACE.forEach(function (level) {\n        var nlevel = _this.opts.levelNumbers ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toNumLevel)(level) : level;\n        var llevel = level.toLowerCase();\n        if (active.includes(level)) {\n          _this._enabled[level] = true;\n          _this[llevel] = level === _utils_js__WEBPACK_IMPORTED_MODULE_1__.FATAL ? function (fmt) {\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            var str = _this._log(nlevel, fmt, args);\n            // @ts-expect-error\n            _this.flush && _this.flush();\n            return str;\n          } : function (fmt) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            return _this._log(nlevel, fmt, args);\n          };\n        } else {\n          _this[llevel] = noop;\n        }\n      });\n      var nLOG = this.opts.levelNumbers ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toNumLevel)(_utils_js__WEBPACK_IMPORTED_MODULE_1__.LOG) : _utils_js__WEBPACK_IMPORTED_MODULE_1__.LOG;\n      this.log = function (fmt) {\n        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          args[_key3 - 1] = arguments[_key3];\n        }\n        return _this._log(nLOG, fmt, args);\n      };\n    }\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      var _this2 = this;\n      return this._enabled._cache || (this._enabled._cache = _utils_js__WEBPACK_IMPORTED_MODULE_1__.LEVELS.TRACE.reduce(function (o, level) {\n        o[level] = o[level.toLowerCase()] = !!_this2._enabled[level];\n        return o;\n      }, {}));\n    }\n  }, {\n    key: \"diff\",\n    value: function diff() {\n      var curr = Date.now();\n      var prev = this._prev || curr;\n      this._prev = curr;\n      return curr - prev;\n    }\n\n    /**\n     * @return {object} json object\n     */\n  }, {\n    key: \"_formatJson\",\n    value: function _formatJson(level, fmt) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var other = {};\n      var msg = this.formatter.format(fmt, args, other) || undefined;\n      var o = _objectSpread({\n        level: level,\n        time: this._time(),\n        name: this.name,\n        msg: msg,\n        pid: this.pid,\n        hostname: this.hostname,\n        diff: this.diff()\n      }, other);\n      return o;\n    }\n  }, {\n    key: \"_applySerializers\",\n    value: function _applySerializers(obj) {\n      var o = {};\n      for (var key in obj) {\n        var value = obj[key];\n        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n          if (this.serializers && this.serializers[key]) {\n            o[key] = this.serializers[key](value);\n          } else {\n            o[key] = value;\n          }\n        }\n      }\n      return o;\n    }\n\n    /* c8 ignore next */\n  }, {\n    key: \"_serverinfo\",\n    value: function _serverinfo() {}\n\n    /**\n     * @protected\n     */\n    /* c8 ignore next 3 */\n  }, {\n    key: \"_log\",\n    value: function _log(nlevel, fmt, args) {\n      throw new Error('needs implementation');\n    }\n  }]);\n  return LogBase;\n}();\n\n//# sourceURL=webpack:///../../src/LogBase.js?");

/***/ }),

/***/ "../../src/Namespaces.js":
/*!*******************************!*\
  !*** ../../src/Namespaces.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Namespaces\": () => (/* binding */ Namespaces)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n * @see https://github.com/visionmedia/debug\n */\n\n\nvar LEVELS = [_utils_js__WEBPACK_IMPORTED_MODULE_0__.TRACE, _utils_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG, _utils_js__WEBPACK_IMPORTED_MODULE_0__.INFO, _utils_js__WEBPACK_IMPORTED_MODULE_0__.WARN, _utils_js__WEBPACK_IMPORTED_MODULE_0__.ERROR, _utils_js__WEBPACK_IMPORTED_MODULE_0__.FATAL, _utils_js__WEBPACK_IMPORTED_MODULE_0__.OFF];\nvar LEVELS_REGEX = RegExp(\"^(\".concat(LEVELS.join('|'), \"):\"), 'i');\nvar Namespaces = /*#__PURE__*/function () {\n  function Namespaces(namespaces) {\n    _classCallCheck(this, Namespaces);\n    this.enable(namespaces);\n    this.skips = [];\n  }\n\n  /**\n   * @param {string} namespaces\n   */\n  _createClass(Namespaces, [{\n    key: \"enable\",\n    value: function enable(namespaces) {\n      this.skips = [];\n      this.names = [];\n      var splited = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n      var _iterator = _createForOfIteratorHelper(splited),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _namespace = _step.value;\n          if (!_namespace) continue; // ignore empty strings\n          var _this$_namespaceNLeve = this._namespaceNLevel(_namespace),\n            namespace = _this$_namespaceNLeve.namespace,\n            level = _this$_namespaceNLeve.level;\n          if (namespace[0] === '-') {\n            this.skips.push({\n              re: new RegExp('^' + namespace.substr(1) + '$')\n            });\n          } else {\n            this.names.push({\n              re: new RegExp('^' + namespace + '$'),\n              level: level\n            });\n          }\n        }\n\n        // sort names by levels\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.names = this.names.sort(function (a, b) {\n        return LEVELS.indexOf(a.level) - LEVELS.indexOf(b.level);\n      });\n    }\n\n    /* c8 ignore next 3 */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enable('');\n    }\n\n    /**\n     * @param {string} name\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled(name, level) {\n      if (name === '*') {\n        return level || 'DEBUG';\n      }\n      if (!this.names.length) {\n        return level;\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.skips),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _skip = _step2.value;\n          if (_skip.re.test(name)) {\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.names),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _name = _step3.value;\n          if (_name.re.test(name)) {\n            return _name.level || level || 'DEBUG';\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    /**\n     * @param {string} _namespace\n     * @private\n     */\n  }, {\n    key: \"_namespaceNLevel\",\n    value: function _namespaceNLevel(_namespace) {\n      var level = (LEVELS_REGEX.exec(_namespace) || [])[1];\n      var namespace = _namespace.replace(LEVELS_REGEX, '').replace(/\\*/g, '.*?');\n      return {\n        namespace: namespace,\n        level: level\n      };\n    }\n  }]);\n  return Namespaces;\n}();\n\n//# sourceURL=webpack:///../../src/Namespaces.js?");

/***/ }),

/***/ "../../src/browser.js":
/*!****************************!*\
  !*** ../../src/browser.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Log\": () => (/* binding */ Log),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var asyncc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! asyncc */ \"../../node_modules/.pnpm/asyncc@2.0.6/node_modules/asyncc/dist/index.es.js\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ms */ \"../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\");\n/* harmony import */ var _LogBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LogBase.js */ \"../../src/LogBase.js\");\n/* harmony import */ var _wrapConsole_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrapConsole.js */ \"../../src/wrapConsole.js\");\n/* harmony import */ var _serializers_err_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./serializers/err.js */ \"../../src/serializers/err.js\");\nvar _excluded = [\"level\", \"name\", \"time\", \"msg\", \"diff\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n/* global navigator window document Image chrome */\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('./utils').Level} Level\n * @typedef {import('./LogBase').LogBaseOptions} LogBaseOptions\n *\n * @typedef {object} ExtLogOptionsBrowser\n * @property {string} [url] url to report errors\n *\n * @typedef {LogBaseOptions & ExtLogOptionsBrowser} LogOptionsBrowser\n */\n\nvar COLOR_RESET = 'color:inherit';\n\n/**\n * global log options\n */\nvar _options = {\n  level: _utils_js__WEBPACK_IMPORTED_MODULE_2__.WARN,\n  namespaces: undefined,\n  colors: true,\n  // apply coloring to browser console\n  url: undefined // [optional]\n};\n\n/**\n * get storage\n * @private\n */\nvar storage = function storage() {\n  try {\n    // @ts-expect-error\n    return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined'\n    // @ts-expect-error\n    ? chrome.storage.local : window.localStorage;\n  } catch (err) {\n    // istanbul ignore next\n    return {};\n  }\n};\n\n/**\n * check if console colors are supported\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n * @private\n */\nvar supportsColors = function supportsColors() {\n  var tmp;\n  var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  var isElectron = typeof window !== 'undefined' && (\n  // @ts-expect-error\n  tmp = window.process) && tmp.type === 'renderer';\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  var isReactNative = typeof document !== 'undefined' && (\n  // @ts-expect-error\n  tmp = document.documentElement) && (tmp = tmp.style) && tmp.WebkitAppearance;\n  // is firebug? http://stackoverflow.com/a/398120/376773\n  var isFireBug = typeof window !== 'undefined' && (\n  // @ts-expect-error\n  tmp = window.console) && (tmp.firebug || tmp.exception && tmp.table);\n  if (isElectron) {\n    // istanbul ignore next\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (/(edge|trident)\\/(\\d+)/i.exec(userAgent)) {\n    // istanbul ignore next\n    return false;\n  }\n  return !!(isReactNative || isFireBug ||\n  // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  /firefox\\/(\\d+)/i.exec(userAgent) && parseInt(RegExp.$1, 10) >= 31 ||\n  // double check webkit in userAgent just in case we are in a worker\n  /applewebkit\\/(\\d+)/i.exec(userAgent));\n};\n\n/**\n * creates a new logger for the browser\n */\nvar Log = /*#__PURE__*/function (_LogBase) {\n  _inherits(Log, _LogBase);\n  var _super = _createSuper(Log);\n  /**\n   * @param {string} name namespace of Logger\n   * @param {LogOptionsBrowser} opts\n   */\n  function Log(name, opts) {\n    var _this;\n    _classCallCheck(this, Log);\n    var _storage = storage();\n    Object.assign(_options, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.inspectOpts)(_storage), (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.inspectNamespaces)(_storage));\n    _options.colors = _options.colors === false ? false : supportsColors();\n    var serializers = Object.assign({}, _options.serializers, opts === null || opts === void 0 ? void 0 : opts.serializers);\n    var _opts = Object.assign({}, _options, opts, {\n      serializers: serializers\n    });\n    _this = _super.call(this, name, _opts);\n    // noop for TS\n    _this.opts = _objectSpread(_objectSpread({}, _opts), _this.opts);\n    var colorFn = function colorFn(c) {\n      return \"color:\".concat(c);\n    };\n    _this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.selectColor)(name, colorFn);\n    _this.levColors = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.levelColors)(colorFn);\n    _this.queue = new asyncc__WEBPACK_IMPORTED_MODULE_0__.Queue(_this._sendLog.bind(_assertThisInitialized(_this)), 3);\n    return _this;\n  }\n\n  /**\n   * Apply (and get) global options\n   * @param {LogOptionsBrowser} [opts] changed options\n   * @return {object} global options\n   */\n  _createClass(Log, [{\n    key: \"render\",\n    value:\n    /**\n     * render arguments to console.log\n     * @public\n     * @param {any[]} args console.log arguments\n     * @param {Level} level level of log line (might be used for custom Logger which uses different streams per level)\n     * @return {any[]}\n     */\n    function render(args, level) {\n      var _console;\n      (_console = console).log.apply(_console, _toConsumableArray(args)); // eslint-disable-line no-console\n      return args;\n    }\n\n    /**\n     * send log to server\n     * @param {Level|object} level log level\n     * @param {string} [fmt] formatter\n     * @param {any[]} [args] log arguments\n     */\n  }, {\n    key: \"send\",\n    value: function send(level, fmt, args) {\n      var obj;\n      if (_typeof(level) === 'object') {\n        obj = level;\n      } else {\n        var uns = this._formatJson(level, fmt, args);\n        obj = this._applySerializers(uns);\n      }\n      obj.userAgent = navigator.userAgent;\n      var str = this.formatter.stringify(obj);\n      this.queue.push(str);\n    }\n\n    /**\n     * format log arguments\n     * @protected\n     */\n  }, {\n    key: \"_log\",\n    value: function _log(level, fmt, args) {\n      var uns = this._formatJson(level, fmt, args);\n      var obj = this._applySerializers(uns);\n      var _args = this._format(obj);\n      var res = this.render(_args, level);\n      if (this.opts.url) {\n        this.send(obj);\n      }\n      return res;\n    }\n\n    /**\n     * format arguments for console.log\n     * @private\n     * @param {object} param0\n     * @return {Array} args for console.log\n     */\n  }, {\n    key: \"_format\",\n    value: function _format(_ref) {\n      var level = _ref.level,\n        name = _ref.name,\n        time = _ref.time,\n        _ref$msg = _ref.msg,\n        msg = _ref$msg === void 0 ? '' : _ref$msg,\n        diff = _ref.diff,\n        other = _objectWithoutProperties(_ref, _excluded);\n      var color = this.color;\n      var args = [];\n      var hasOther = Object.keys(other).length;\n      args[0] = [this._color(level), this._color(name), msg, hasOther ? '%O' : undefined, this._color('+' + ms__WEBPACK_IMPORTED_MODULE_1__(diff))].filter(function (s) {\n        return s !== undefined;\n      }).join(' ');\n      if (hasOther) args.push(other);\n      if (this.opts.colors) {\n        args.splice(1, 0, color + ';font-weight:bold', COLOR_RESET);\n        args.splice(1, 0, this.levColors[level], COLOR_RESET);\n      }\n      if (this.opts.colors) {\n        var idx = 0;\n        var lastC = 0;\n        args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n          idx++;\n          if (format === 'c') {\n            lastC = idx;\n          }\n          return match;\n        });\n        args.splice(lastC - 1, 0, color, COLOR_RESET);\n      }\n      return args;\n    }\n\n    /**\n     * transfer log to server via zero pixel image request\n     * @param {string} str\n     * @param {Function} [cb]\n     */\n  }, {\n    key: \"_sendLog\",\n    value: function _sendLog(str, cb) {\n      var img = new Image();\n      var done = function done() {\n        cb && cb();\n      };\n      img.onload = done;\n      img.onerror = done;\n      img.onabort = done;\n      img.src = this.opts.url + '?id=' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.random)(6) + '&log=' + encodeURIComponent(str);\n    }\n\n    /**\n     * Add colors, style to string\n     * @private\n     */\n  }, {\n    key: \"_color\",\n    value: function _color(str) {\n      return this.opts.colors ? \"%c\".concat(str, \"%c\") : str;\n    }\n  }], [{\n    key: \"options\",\n    value: function options(opts) {\n      if (!opts) {\n        return Object.assign({}, _options);\n      }\n      Object.assign(_options, opts, {\n        colors: opts.colors === false ? false : supportsColors()\n      });\n      return _options;\n    }\n\n    /**\n     * save options in `localStorage`\n     */\n  }, {\n    key: \"save\",\n    value: function save() {\n      var _storage = storage();\n      Log.reset();\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.saveOpts)(_storage, _options);\n    }\n\n    /**\n     * reset saved options\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var _storage = storage();\n      Object.keys(_storage).forEach(function (key) {\n        if (/^(DEBUG|DEBUG_.*)$/i.test(key)) {\n          _storage.removeItem(key);\n        }\n      });\n    }\n\n    /**\n     * @typedef {object} ExtLogOptionWrapConsole\n     * @property {Level} [level4log='LOG']\n     *\n     * @typedef {LogOptionsBrowser & ExtLogOptionWrapConsole} LogOptionWrapConsole\n     */\n    /**\n     * wrap console logging functions like\n     * console.log, console.info, console.warn, console.error\n     * @param {string} [name='console']\n     * @param {LogOptionWrapConsole} [opts]\n     * @return {function} unwrap function\n     */\n  }, {\n    key: \"wrapConsole\",\n    value: function wrapConsole() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'console';\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var log = new Log(name, opts);\n      return (0,_wrapConsole_js__WEBPACK_IMPORTED_MODULE_4__.wrapConsole)(log, opts);\n    }\n  }]);\n  return Log;\n}(_LogBase_js__WEBPACK_IMPORTED_MODULE_3__.LogBase);\nLog.serializers = {\n  err: _serializers_err_js__WEBPACK_IMPORTED_MODULE_5__.errSerializer\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Log);\n\n//# sourceURL=webpack:///../../src/browser.js?");

/***/ }),

/***/ "../../src/quick-format.js":
/*!*********************************!*\
  !*** ../../src/quick-format.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"format\": () => (/* binding */ format)\n/* harmony export */ });\nvar _excluded = [\"name\", \"level\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/**\n * @credits quick-format-unescaped\n * @license The MIT License (MIT)\n * @copyright Copyright (c) 2016-2019 David Mark Clements\n */\n\nfunction tryStringify(o) {\n  try {\n    return JSON.stringify(o);\n  } catch (e) {\n    return '\"[Circular]\"';\n  }\n}\nfunction format(f, args, opts) {\n  var obj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var ss = opts && opts.stringify || tryStringify;\n  var argLen = args.length;\n  var a = 0;\n  var str = '';\n  var type = _typeof(f);\n  var procObj = function procObj(val) {\n    if (Array.isArray(val)) {\n      Object.assign(obj, {\n        arr: val\n      });\n    } else if (val instanceof Error) {\n      // } else if (val.stack && val.message && val.name) {\n      if (!str) str = val.message;\n      Object.assign(obj, {\n        err: val\n      });\n    } else {\n      var name = val.name,\n        level = val.level,\n        other = _objectWithoutProperties(val, _excluded);\n      Object.assign(obj, other);\n    }\n  };\n  if (type === 'function') {\n    str = toFunctionSting(f.name);\n  } else if (type === 'object' && f !== null) {\n    str = f.msg || '';\n    procObj(f);\n  } else if (type !== 'string') {\n    str = String(f);\n  } else if (type === 'string') {\n    if (argLen === 0) return f;\n    var lastPos = -1;\n    var flen = f && f.length || 0;\n    for (var i = 0; i < flen;) {\n      if (f.charCodeAt(i) === 37 && i + 1 < flen) {\n        lastPos = lastPos > -1 ? lastPos : 0;\n        switch (f.charCodeAt(i + 1)) {\n          case 100: // 'd'\n          case 102:\n            // 'f'\n            if (a >= argLen) {\n              break;\n            }\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n            if (args[a] == null) break;\n            str += Number(args[a]);\n            lastPos = i = i + 2;\n            break;\n          case 105:\n            // 'i'\n            if (a >= argLen) {\n              break;\n            }\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n            if (args[a] == null) break;\n            str += Math.floor(Number(args[a]));\n            lastPos = i = i + 2;\n            break;\n          case 79: // 'O'\n          case 111: // 'o'\n          case 106:\n            {\n              // 'j'\n              if (a >= argLen) {\n                break;\n              }\n              if (lastPos < i) {\n                str += f.slice(lastPos, i);\n              }\n              if (args[a] === undefined) break;\n              var _type = _typeof(args[a]);\n              if (_type === 'string') {\n                str += '\\'' + args[a] + '\\'';\n                lastPos = i + 2;\n                i++;\n                break;\n              }\n              if (_type === 'function') {\n                str += toFunctionSting(args[a].name);\n                lastPos = i + 2;\n                i++;\n                break;\n              }\n              str += ss(args[a]);\n              lastPos = i + 2;\n              i++;\n              break;\n            }\n          case 115:\n            // 's'\n            if (a >= argLen) {\n              break;\n            }\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n            str += String(args[a]);\n            lastPos = i + 2;\n            i++;\n            break;\n          case 37:\n            // '%'\n            if (lastPos < i) {\n              str += f.slice(lastPos, i);\n            }\n            str += '%';\n            lastPos = i + 2;\n            i++;\n            a--; // stay on same argument\n            break;\n        }\n        ++a;\n      }\n      ++i;\n    }\n    if (lastPos === -1) {\n      str = f;\n    } else if (lastPos < flen) {\n      str += f.slice(lastPos);\n    }\n  }\n  for (a; a < argLen; a++) {\n    var val = args[a];\n    var _type2 = _typeof(val);\n    if (_type2 === 'function') {\n      str += ' ' + toFunctionSting(val.name);\n    } else if (_type2 === 'object' && val !== null) {\n      procObj(val);\n    } else {\n      str += ' ' + String(val);\n    }\n  }\n  return str;\n}\nvar toFunctionSting = function toFunctionSting(name) {\n  return (name || '<anonymous>') + '()';\n};\n\n//# sourceURL=webpack:///../../src/quick-format.js?");

/***/ }),

/***/ "../../src/serializers/err.js":
/*!************************************!*\
  !*** ../../src/serializers/err.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"errSerializer\": () => (/* binding */ errSerializer)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar circ = Symbol('circ');\n\n/**\n * @param {object} [val]\n * @returns {object}\n */\nfunction errSerializer(val) {\n  if (!(val instanceof Error)) {\n    return val;\n  }\n  var o = {\n    msg: val.message,\n    name: Object.prototype.toString.call(val.constructor) === '[object Function]' ? val.constructor.name : val.name,\n    stack: val.stack\n  };\n  val[circ] = undefined;\n  Object.entries(val).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      val = _ref2[1];\n    if (o[key] === undefined) {\n      if (val instanceof Error) {\n        if (!Object.prototype.hasOwnProperty.call(val, circ)) {\n          o[key] = errSerializer(val);\n        }\n      } else {\n        o[key] = val;\n      }\n    }\n  });\n  return o;\n}\n\n//# sourceURL=webpack:///../../src/serializers/err.js?");

/***/ }),

/***/ "../../src/utils.js":
/*!**************************!*\
  !*** ../../src/utils.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLORS\": () => (/* binding */ COLORS),\n/* harmony export */   \"DEBUG\": () => (/* binding */ DEBUG),\n/* harmony export */   \"ERROR\": () => (/* binding */ ERROR),\n/* harmony export */   \"FATAL\": () => (/* binding */ FATAL),\n/* harmony export */   \"INFO\": () => (/* binding */ INFO),\n/* harmony export */   \"LEVELS\": () => (/* binding */ LEVELS),\n/* harmony export */   \"LEVEL_COLORS\": () => (/* binding */ LEVEL_COLORS),\n/* harmony export */   \"LOG\": () => (/* binding */ LOG),\n/* harmony export */   \"NUM_LEVELS\": () => (/* binding */ NUM_LEVELS),\n/* harmony export */   \"OFF\": () => (/* binding */ OFF),\n/* harmony export */   \"TRACE\": () => (/* binding */ TRACE),\n/* harmony export */   \"WARN\": () => (/* binding */ WARN),\n/* harmony export */   \"adjustLevel\": () => (/* binding */ adjustLevel),\n/* harmony export */   \"fromNumLevel\": () => (/* binding */ fromNumLevel),\n/* harmony export */   \"inspectNamespaces\": () => (/* binding */ inspectNamespaces),\n/* harmony export */   \"inspectOpts\": () => (/* binding */ inspectOpts),\n/* harmony export */   \"levelColors\": () => (/* binding */ levelColors),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"saveOpts\": () => (/* binding */ saveOpts),\n/* harmony export */   \"selectColor\": () => (/* binding */ selectColor),\n/* harmony export */   \"toNumLevel\": () => (/* binding */ toNumLevel)\n/* harmony export */ });\nvar _NUM_LEVELS;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * @license MIT\n * @copyright debug contributors, <commenthol@gmail.com>\n */\n\n/** @typedef {'LOG'|'FATAL'|'ERROR'|'WARN'|'INFO'|'DEBUG'|'TRACE'|'OFF'} Level */\n\n/** @type {Level} */\nvar LOG = 'LOG';\n/** @type {Level} */\nvar FATAL = 'FATAL';\n/** @type {Level} */\nvar ERROR = 'ERROR';\n/** @type {Level} */\nvar WARN = 'WARN';\n/** @type {Level} */\nvar INFO = 'INFO';\n/** @type {Level} */\nvar DEBUG = 'DEBUG';\n/** @type {Level} */\nvar TRACE = 'TRACE';\n/** @type {Level} */\nvar OFF = 'OFF';\nvar LEVELS = {\n  TRACE: [FATAL, ERROR, WARN, INFO, DEBUG, TRACE],\n  DEBUG: [FATAL, ERROR, WARN, INFO, DEBUG],\n  INFO: [FATAL, ERROR, WARN, INFO],\n  WARN: [FATAL, ERROR, WARN],\n  ERROR: [FATAL, ERROR],\n  FATAL: [FATAL],\n  OFF: [OFF]\n};\nvar COLORS = ['#6600FF', '#3333FF', '#3333CC', '#0066FF', '#0066CC', '#0066FF', '#006633', '#006666', '#006600', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#009900', '#009933', '#009966', '#009999', '#00CCFF', '#00CCCC', '#FF9900', '#FF9933', '#FF6600', '#FF6633', '#FF0000', '#FF0033', '#FF3300', '#FF3300', '#FF3333', '#CC0000', '#CC0033', '#CC0066', '#FF0066', '#FF3366', '#FF00FF', '#FF33FF', '#CC00CC', '#990099'];\nvar LEVEL_COLORS = {\n  LOG: '#999999',\n  TRACE: '#00CCFF',\n  DEBUG: '#0066CC',\n  INFO: '#009900',\n  WARN: '#FF9900',\n  ERROR: '#CC0000',\n  FATAL: '#CC00CC'\n};\nvar NUM_LEVELS = (_NUM_LEVELS = {}, _defineProperty(_NUM_LEVELS, TRACE, 10), _defineProperty(_NUM_LEVELS, DEBUG, 20), _defineProperty(_NUM_LEVELS, INFO, 30), _defineProperty(_NUM_LEVELS, LOG, 30), _defineProperty(_NUM_LEVELS, WARN, 40), _defineProperty(_NUM_LEVELS, ERROR, 50), _defineProperty(_NUM_LEVELS, FATAL, 60), _NUM_LEVELS);\nvar adjustLevel = function adjustLevel(level, _default) {\n  level = (level || '').toUpperCase();\n  return LEVELS[level] ? level : _default;\n};\n\n/**\n * @param {Level} level\n * @returns {number}\n */\nvar toNumLevel = function toNumLevel(level) {\n  return NUM_LEVELS[level] || NUM_LEVELS.DEBUG;\n};\n\n/**\n * @param {number} level\n */\nvar fromNumLevel = function fromNumLevel(level) {\n  if (typeof level === 'number') {\n    for (var slevel in NUM_LEVELS) {\n      var threshold = NUM_LEVELS[slevel];\n      if (level <= threshold) {\n        return slevel;\n      }\n    }\n    return FATAL;\n  }\n  return level;\n};\n\n/**\n * @copyright debug contributors\n * @see https://github.com/visionmedia/debug\n */\nvar inspectOpts = function inspectOpts(obj) {\n  return Object.keys(obj).filter(function (key) {\n    return /^debug_/i.test(key);\n  }).reduce(function (opts, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n      return k.toUpperCase();\n    });\n\n    // coerce string value into JS value\n    var val = obj[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n    if (prop === 'stream' || prop === 'formatters') {\n      // do nothing\n    } else if (prop === 'level') {\n      val = adjustLevel(obj[key]);\n      if (val) opts[prop] = val;\n    } else if (prop === 'url' || prop === 'timestamp') {\n      opts[prop] = obj[key];\n    } else {\n      opts[prop] = val;\n    }\n    return opts;\n  }, {});\n};\nvar saveOpts = function saveOpts(obj, options) {\n  Object.keys(options).forEach(function (prop) {\n    if (['stream', 'serializers'].includes(prop)) return; // do not safe stream option\n    var key = 'DEBUG_' + prop.replace(/([A-Z])/g, function (_, prop) {\n      return '_' + prop.toLowerCase();\n    });\n    if (prop === 'namespaces') key = 'DEBUG';\n    key = key.toUpperCase();\n    obj[key] = options[prop];\n  });\n};\nvar selectColor = function selectColor(namespace, fn) {\n  var hash = 0;\n  for (var i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  var pos = Math.abs(hash) % COLORS.length;\n  var color = fn(COLORS[pos]);\n  return color;\n};\nvar levelColors = function levelColors(fn) {\n  var colors = Object.keys(LEVEL_COLORS).reduce(function (colors, level) {\n    colors[level] = fn(LEVEL_COLORS[level]);\n    return colors;\n  }, {});\n  return colors;\n};\nvar inspectNamespaces = function inspectNamespaces(obj) {\n  var namespaces = obj.DEBUG || obj.debug;\n  if (namespaces) return {\n    namespaces: namespaces\n  };\n};\nvar random = function random(len) {\n  return Math.random().toString(16).toLowerCase().slice(2, len);\n};\n\n//# sourceURL=webpack:///../../src/utils.js?");

/***/ }),

/***/ "../../src/wrapConsole.js":
/*!********************************!*\
  !*** ../../src/wrapConsole.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrapConsole\": () => (/* binding */ wrapConsole)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../src/utils.js\");\n\nvar LEVELS = [_utils_js__WEBPACK_IMPORTED_MODULE_0__.LOG, _utils_js__WEBPACK_IMPORTED_MODULE_0__.TRACE, _utils_js__WEBPACK_IMPORTED_MODULE_0__.DEBUG, _utils_js__WEBPACK_IMPORTED_MODULE_0__.INFO, _utils_js__WEBPACK_IMPORTED_MODULE_0__.WARN, _utils_js__WEBPACK_IMPORTED_MODULE_0__.ERROR];\nvar wrapped = null;\nvar unwrap = function unwrap() {\n  if (wrapped) {\n    LEVELS.forEach(function (level) {\n      console[level] = wrapped[level];\n    });\n    wrapped = null;\n  }\n};\n\n/**\n * wrap console logging functions like\n * console.log, console.info, console.warn, console.error\n * @return unwrap function\n */\nfunction wrapConsole(log) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$level4log = _ref.level4log,\n    level4log = _ref$level4log === void 0 ? 'LOG' : _ref$level4log;\n  if (wrapped) return unwrap;\n  wrapped = {};\n  var _level4log = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.adjustLevel)(level4log, 'LOG').toLowerCase();\n  var render = function render(level) {\n    return function () {\n      log[level].apply(log, arguments);\n    };\n  };\n  LEVELS.map(function (l) {\n    return l.toLowerCase();\n  }).forEach(function (level) {\n    wrapped[level] = console[level];\n    var renderLevel = level === 'log' ? _level4log : level;\n    console[level] = render(renderLevel);\n  });\n  return unwrap;\n}\n\n//# sourceURL=webpack:///../../src/wrapConsole.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;